{"function": {"cv": [{"name": "bool VideoCapture::retrieve(Mat& image, int channel)", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "bool VideoWriter::open(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)", "pars": [{"name": "writer", "description": " \u2013 Video writer structure (OpenCV 1.x API)", "type": null}, {"name": "image", "description": " \u2013 The written frame", "type": null}], "description": "Releases the AVI writer.", "return_type": "non-return-type", "fname": "releasevideowriter"}, {"name": "VideoCapture::VideoCapture(int device)", "pars": [{"name": "filename", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "type": null}, {"name": "device", "description": " \u2013 id of the opened video capturing device (i.e. a camera index). If there is a single camera connected, just pass 0.", "type": null}], "description": "VideoCapture constructors.", "return_type": "non-return-type", "fname": "videocapture"}, {"name": "bool VideoCapture::grab()", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "bool VideoCapture::isOpened()", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "VideoWriter& VideoWriter::operator << (const Mat& image)", "pars": [{"name": "writer", "description": " \u2013 Video writer structure (OpenCV 1.x API)", "type": null}, {"name": "image", "description": " \u2013 The written frame", "type": null}], "description": "Releases the AVI writer.", "return_type": "non-return-type", "fname": "releasevideowriter"}, {"name": "bool VideoWriter::isOpened()", "pars": [{"name": "writer", "description": " \u2013 Video writer structure (OpenCV 1.x API)", "type": null}, {"name": "image", "description": " \u2013 The written frame", "type": null}], "description": "Releases the AVI writer.", "return_type": "non-return-type", "fname": "releasevideowriter"}, {"name": "Mat imdecode(InputArray buf, int flags, Mat* dst)", "pars": [{"name": "buf", "description": " \u2013 Input array or vector of bytes.", "type": "InputArray"}, {"name": "flags", "description": " \u2013 The same flags as in <a class=\"reference internal\" href=\"#Mat imread(const string& filename, int flags)\" title=\"Mat imread(const string& filename, int flags)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imread()</span></tt></a> .", "type": "int"}, {"name": "dst", "description": " \u2013 The optional output placeholder for the decoded matrix. It can save the image reallocations when the function is called repeatedly for images of the same size.", "type": "Mat*"}], "description": "Reads an image from a buffer in memory.", "return_type": "Mat", "fname": "imdecode"}, {"name": "VideoWriter::VideoWriter(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)", "pars": [{"name": "filename", "description": " \u2013 Name of the output video file.", "type": null}, {"name": "fourcc", "description": " \u2013 4-character code of codec used to compress the frames. For example, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('P','I','M','1')</span></tt> is a MPEG-1 codec, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('M','J','P','G')</span></tt> is a motion-jpeg codec etc. List of codes can be obtained at <a class=\"reference external\" href=\"http://www.fourcc.org/codecs.php\">Video Codecs by FOURCC</a> page.", "type": null}, {"name": "fps", "description": " \u2013 Framerate of the created video stream.", "type": null}, {"name": "frameSize", "description": " \u2013 Size of the video frames.", "type": null}, {"name": "isColor", "description": " \u2013 If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only).", "type": null}], "description": "VideoWriter constructors", "return_type": "non-return-type", "fname": "videowriter"}, {"name": "Mat imdecode(InputArray buf, int flags)", "pars": [{"name": "buf", "description": " \u2013 Input array or vector of bytes.", "type": "InputArray"}, {"name": "flags", "description": " \u2013 The same flags as in <a class=\"reference internal\" href=\"#Mat imread(const string& filename, int flags)\" title=\"Mat imread(const string& filename, int flags)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imread()</span></tt></a> .", "type": "int"}, {"name": "dst", "description": " \u2013 The optional output placeholder for the decoded matrix. It can save the image reallocations when the function is called repeatedly for images of the same size.", "type": null}], "description": "Reads an image from a buffer in memory.", "return_type": "Mat", "fname": "imdecode"}, {"name": "void VideoWriter::write(const Mat& image)", "pars": [{"name": "writer", "description": " \u2013 Video writer structure (OpenCV 1.x API)", "type": null}, {"name": "image", "description": " \u2013 The written frame", "type": null}], "description": "Releases the AVI writer.", "return_type": "non-return-type", "fname": "releasevideowriter"}, {"name": "Mat imread(const string& filename, int flags)", "pars": [{"name": "filename", "description": " \u2013 Name of file to be loaded.", "type": "const string&"}, {"name": "flags", "description": " \u2013 <p>Flags specifying the color type of a loaded image:</p> <ul> <li>CV_LOAD_IMAGE_ANYDEPTH - If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.", "type": "int"}, {"name": ">0", "description": " Return a 3-channel color image.</dt> <dd><div class=\"first last admonition note\"> <p class=\"first admonition-title\">Note</p> <p class=\"last\">In the current implementation the alpha channel, if any, is stripped from the output image. Use negative value if you need the alpha channel.</p> </div> </dd> </dl> ", "type": null}, {"name": "=0", "description": " Return a grayscale image.", "type": null}, {"name": "<0", "description": " Return the loaded image as is (with alpha channel).", "type": null}], "description": "Loads an image from a file.", "return_type": "Mat", "fname": "imread"}, {"name": "VideoCapture::VideoCapture(const string& filename)", "pars": [{"name": "filename", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "type": null}, {"name": "device", "description": " \u2013 id of the opened video capturing device (i.e. a camera index). If there is a single camera connected, just pass 0.", "type": null}], "description": "VideoCapture constructors.", "return_type": "non-return-type", "fname": "videocapture"}, {"name": "bool imencode(const string& ext, InputArray img, vector<uchar>& buf, const vector<int>& params)", "pars": [{"name": "ext", "description": " \u2013 File extension that defines the output format.", "type": "const string&"}, {"name": "img", "description": " \u2013 Image to be written.", "type": "InputArray"}, {"name": "buf", "description": " \u2013 Output buffer resized to fit the compressed image.", "type": "vector<uchar>&"}, {"name": "params", "description": " \u2013 Format-specific parameters. See <a class=\"reference internal\" href=\"#bool imwrite(const string& filename, InputArray img, const vector<int>& params)\" title=\"bool imwrite(const string& filename, InputArray img, const vector<int>& params)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imwrite()</span></tt></a> .", "type": "const vector<int>&"}], "description": "Encodes an image into a memory buffer.", "return_type": "bool", "fname": "imencode"}, {"name": "bool VideoCapture::open(int device)", "pars": [{"name": "filename", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "type": null}, {"name": "device", "description": " \u2013 id of the opened video capturing device (i.e. a camera index).", "type": null}], "description": "Open video file or a capturing device for video capturing", "return_type": "non-return-type", "fname": "videocapture-open"}, {"name": "bool VideoCapture::open(const string& filename)", "pars": [{"name": "filename", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "type": null}, {"name": "device", "description": " \u2013 id of the opened video capturing device (i.e. a camera index).", "type": null}], "description": "Open video file or a capturing device for video capturing", "return_type": "non-return-type", "fname": "videocapture-open"}, {"name": "VideoCapture& VideoCapture::operator >> (Mat& image)", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "bool imwrite(const string& filename, InputArray img, const vector<int>& params)", "pars": [{"name": "filename", "description": " \u2013 Name of the file.", "type": "const string&"}, {"name": "img", "description": null, "type": "InputArray"}, {"name": "params", "description": " \u2013 <p>Format-specific save parameters encoded as pairs <tt class=\"docutils literal\"><span class=\"pre\">paramId_1,</span> <span class=\"pre\">paramValue_1,</span> <span class=\"pre\">paramId_2,</span> <span class=\"pre\">paramValue_2,</span> <span class=\"pre\">...</span></tt> . The following parameters are currently supported:</p> <ul> <li>For JPEG, it can be a quality ( <tt class=\"docutils literal\"><span class=\"pre\">CV_IMWRITE_JPEG_QUALITY</span></tt> ) from 0 to 100 (the higher is the better). Default value is 95.", "type": "const vector<int>&"}, {"name": "image", "description": " \u2013 Image to be saved.", "type": null}], "description": "Saves an image to a specified file.", "return_type": "bool", "fname": "imwrite"}, {"name": "VideoCapture::VideoCapture()", "pars": [{"name": "filename", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "type": null}, {"name": "device", "description": " \u2013 id of the opened video capturing device (i.e. a camera index). If there is a single camera connected, just pass 0.", "type": null}], "description": "VideoCapture constructors.", "return_type": "non-return-type", "fname": "videocapture"}, {"name": "void VideoCapture::release()", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "bool VideoCapture::read(Mat& image)", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "double VideoCapture::get(int propId)", "pars": [], "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "fname": "videocapture-isopened"}, {"name": "VideoWriter::VideoWriter()", "pars": [{"name": "filename", "description": " \u2013 Name of the output video file.", "type": null}, {"name": "fourcc", "description": " \u2013 4-character code of codec used to compress the frames. For example, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('P','I','M','1')</span></tt> is a MPEG-1 codec, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('M','J','P','G')</span></tt> is a motion-jpeg codec etc. List of codes can be obtained at <a class=\"reference external\" href=\"http://www.fourcc.org/codecs.php\">Video Codecs by FOURCC</a> page.", "type": null}, {"name": "fps", "description": " \u2013 Framerate of the created video stream.", "type": null}, {"name": "frameSize", "description": " \u2013 Size of the video frames.", "type": null}, {"name": "isColor", "description": " \u2013 If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only).", "type": null}], "description": "VideoWriter constructors", "return_type": "non-return-type", "fname": "videowriter"}, {"name": "bool VideoCapture::set(int propId, double value)", "pars": [{"name": "propId", "description": " \u2013 <p>Property identifier. It can be one of the following:</p> <ul> <li><strong>CV_CAP_PROP_POS_MSEC</strong> Current position of the video file in milliseconds.", "type": null}, {"name": "CV_CAP_PROP_POS_FRAMES", "description": " 0-based index of the frame to be decoded/captured next.", "type": null}, {"name": "CV_CAP_PROP_POS_AVI_RATIO", "description": " Relative position of the video file: 0 - start of the film, 1 - end of the film.", "type": null}, {"name": "CV_CAP_PROP_FRAME_WIDTH", "description": " Width of the frames in the video stream.", "type": null}, {"name": "CV_CAP_PROP_FRAME_HEIGHT", "description": " Height of the frames in the video stream.", "type": null}, {"name": "CV_CAP_PROP_FPS", "description": " Frame rate.", "type": null}, {"name": "CV_CAP_PROP_FOURCC", "description": " 4-character code of codec.", "type": null}, {"name": "CV_CAP_PROP_FRAME_COUNT", "description": " Number of frames in the video file.", "type": null}, {"name": "CV_CAP_PROP_FORMAT", "description": " Format of the Mat objects returned by <tt class=\"docutils literal\"><span class=\"pre\">retrieve()</span></tt> .", "type": null}, {"name": "CV_CAP_PROP_MODE", "description": " Backend-specific value indicating the current capture mode.", "type": null}, {"name": "CV_CAP_PROP_BRIGHTNESS", "description": " Brightness of the image (only for cameras).", "type": null}, {"name": "CV_CAP_PROP_CONTRAST", "description": " Contrast of the image (only for cameras).", "type": null}, {"name": "CV_CAP_PROP_SATURATION", "description": " Saturation of the image (only for cameras).", "type": null}, {"name": "CV_CAP_PROP_HUE", "description": " Hue of the image (only for cameras).", "type": null}, {"name": "CV_CAP_PROP_GAIN", "description": " Gain of the image (only for cameras).", "type": null}, {"name": "CV_CAP_PROP_EXPOSURE", "description": " Exposure (only for cameras).", "type": null}, {"name": "CV_CAP_PROP_CONVERT_RGB", "description": " Boolean flags indicating whether images should be converted to RGB.", "type": null}, {"name": "CV_CAP_PROP_WHITE_BALANCE", "description": " Currently unsupported", "type": null}, {"name": "CV_CAP_PROP_RECTIFICATION", "description": " Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)", "type": null}, {"name": "value", "description": " \u2013 Value of the property.", "type": null}], "description": "Sets a property in the <tt class=\"docutils literal\"><span class=\"pre\">VideoCapture</span></tt>.", "return_type": "non-return-type", "fname": "videocapture-set"}]}}