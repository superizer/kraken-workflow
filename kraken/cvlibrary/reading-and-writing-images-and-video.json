{"function": {"cv": [{"return_type": "Mat", "pars": [{"name": "filename", "type": "const string&", "description": " \u2013 Name of file to be loaded."}, {"name": "flags", "type": "int", "description": " \u2013 <p>Flags specifying the color type of a loaded image:</p> <ul> <li>CV_LOAD_IMAGE_ANYDEPTH - If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit."}], "name": "Mat imread(const string& filename, int flags)", "fname": "imread", "description": "Loads an image from a file."}, {"return_type": "bool", "pars": [{"name": "image", "type": "Mat&", "description": null}, {"name": "channel", "type": "int", "description": null}], "name": "bool VideoCapture::retrieve(Mat& image, int channel)", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "Mat", "pars": [{"name": "buf", "type": "InputArray", "description": " \u2013 Input array or vector of bytes."}, {"name": "flags", "type": "int", "description": " \u2013 The same flags as in <a class=\"reference internal\" href=\"#Mat imread(const string& filename, int flags)\" title=\"Mat imread(const string& filename, int flags)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imread()</span></tt></a> ."}, {"name": "dst", "type": "Mat*", "description": " \u2013 The optional output placeholder for the decoded matrix. It can save the image reallocations when the function is called repeatedly for images of the same size."}], "name": "Mat imdecode(InputArray buf, int flags, Mat* dst)", "fname": "imdecode", "description": "Reads an image from a buffer in memory."}, {"return_type": "non-return-type", "pars": [{"name": "device", "type": "int", "description": " \u2013 id of the opened video capturing device (i.e. a camera index). If there is a single camera connected, just pass 0."}], "name": "VideoCapture::VideoCapture(int device)", "fname": "videocapture", "description": "VideoCapture constructors."}, {"return_type": "Mat", "pars": [{"name": "buf", "type": "InputArray", "description": " \u2013 Input array or vector of bytes."}, {"name": "flags", "type": "int", "description": " \u2013 The same flags as in <a class=\"reference internal\" href=\"#Mat imread(const string& filename, int flags)\" title=\"Mat imread(const string& filename, int flags)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imread()</span></tt></a> ."}], "name": "Mat imdecode(InputArray buf, int flags)", "fname": "imdecode", "description": "Reads an image from a buffer in memory."}, {"return_type": "non-return-type", "pars": [], "name": "VideoWriter& VideoWriter::operator << (const Mat& image)", "fname": "releasevideowriter", "description": "Releases the AVI writer."}, {"return_type": "bool", "pars": [{"name": "propId", "type": "int", "description": " \u2013 <p>Property identifier. It can be one of the following:</p> <ul> <li><strong>CV_CAP_PROP_POS_MSEC</strong> Current position of the video file in milliseconds."}, {"name": "value", "type": "double", "description": " \u2013 Value of the property."}], "name": "bool VideoCapture::set(int propId, double value)", "fname": "videocapture-set", "description": "Sets a property in the <tt class=\"docutils literal\"><span class=\"pre\">VideoCapture</span></tt>."}, {"return_type": "void", "pars": [{"name": "image", "type": "const Mat&", "description": " \u2013 The written frame"}], "name": "void VideoWriter::write(const Mat& image)", "fname": "releasevideowriter", "description": "Releases the AVI writer."}, {"return_type": "bool", "pars": [{"name": "filename", "type": "const string&", "description": null}, {"name": "fourcc", "type": "int", "description": null}, {"name": "fps", "type": "double", "description": null}, {"name": "frameSize", "type": "Size", "description": null}, {"name": "isColor", "type": "bool", "description": null}], "name": "bool VideoWriter::open(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)", "fname": "releasevideowriter", "description": "Releases the AVI writer."}, {"return_type": "double", "pars": [{"name": "propId", "type": "int", "description": null}], "name": "double VideoCapture::get(int propId)", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "bool", "pars": [{"name": "image", "type": "Mat&", "description": null}], "name": "bool VideoCapture::read(Mat& image)", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "bool", "pars": [], "name": "bool VideoCapture::isOpened()", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "bool", "pars": [{"name": "device", "type": "int", "description": " \u2013 id of the opened video capturing device (i.e. a camera index)."}], "name": "bool VideoCapture::open(int device)", "fname": "videocapture-open", "description": "Open video file or a capturing device for video capturing"}, {"return_type": "non-return-type", "pars": [{"name": "filename", "type": "const string&", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)"}], "name": "VideoCapture::VideoCapture(const string& filename)", "fname": "videocapture", "description": "VideoCapture constructors."}, {"return_type": "bool", "pars": [{"name": "filename", "type": "const string&", "description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)"}], "name": "bool VideoCapture::open(const string& filename)", "fname": "videocapture-open", "description": "Open video file or a capturing device for video capturing"}, {"return_type": "non-return-type", "pars": [], "name": "VideoCapture& VideoCapture::operator >> (Mat& image)", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "non-return-type", "pars": [], "name": "VideoCapture::VideoCapture()", "fname": "videocapture", "description": "VideoCapture constructors."}, {"return_type": "bool", "pars": [], "name": "bool VideoCapture::grab()", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "non-return-type", "pars": [], "name": "VideoWriter::VideoWriter()", "fname": "videowriter", "description": "VideoWriter constructors"}, {"return_type": "bool", "pars": [{"name": "ext", "type": "const string&", "description": " \u2013 File extension that defines the output format."}, {"name": "img", "type": "InputArray", "description": " \u2013 Image to be written."}, {"name": "buf", "type": "vector<uchar>&", "description": " \u2013 Output buffer resized to fit the compressed image."}, {"name": "params", "type": "const vector<int>&", "description": " \u2013 Format-specific parameters. See <a class=\"reference internal\" href=\"#bool imwrite(const string& filename, InputArray img, const vector<int>& params)\" title=\"bool imwrite(const string& filename, InputArray img, const vector<int>& params)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imwrite()</span></tt></a> ."}], "name": "bool imencode(const string& ext, InputArray img, vector<uchar>& buf, const vector<int>& params)", "fname": "imencode", "description": "Encodes an image into a memory buffer."}, {"return_type": "bool", "pars": [], "name": "bool VideoWriter::isOpened()", "fname": "releasevideowriter", "description": "Releases the AVI writer."}, {"return_type": "void", "pars": [], "name": "void VideoCapture::release()", "fname": "videocapture-isopened", "description": "Returns true if video capturing has been initialized already."}, {"return_type": "non-return-type", "pars": [{"name": "filename", "type": "const string&", "description": " \u2013 Name of the output video file."}, {"name": "fourcc", "type": "int", "description": " \u2013 4-character code of codec used to compress the frames. For example, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('P','I','M','1')</span></tt> is a MPEG-1 codec, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('M','J','P','G')</span></tt> is a motion-jpeg codec etc. List of codes can be obtained at <a class=\"reference external\" href=\"http://www.fourcc.org/codecs.php\">Video Codecs by FOURCC</a> page."}, {"name": "fps", "type": "double", "description": " \u2013 Framerate of the created video stream."}, {"name": "frameSize", "type": "Size", "description": " \u2013 Size of the video frames."}, {"name": "isColor", "type": "bool", "description": " \u2013 If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only)."}], "name": "VideoWriter::VideoWriter(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)", "fname": "videowriter", "description": "VideoWriter constructors"}, {"return_type": "bool", "pars": [{"name": "filename", "type": "const string&", "description": " \u2013 Name of the file."}, {"name": "img", "type": "InputArray", "description": null}, {"name": "params", "type": "const vector<int>&", "description": " \u2013 <p>Format-specific save parameters encoded as pairs <tt class=\"docutils literal\"><span class=\"pre\">paramId_1,</span> <span class=\"pre\">paramValue_1,</span> <span class=\"pre\">paramId_2,</span> <span class=\"pre\">paramValue_2,</span> <span class=\"pre\">...</span></tt> . The following parameters are currently supported:</p> <ul> <li>For JPEG, it can be a quality ( <tt class=\"docutils literal\"><span class=\"pre\">CV_IMWRITE_JPEG_QUALITY</span></tt> ) from 0 to 100 (the higher is the better). Default value is 95."}], "name": "bool imwrite(const string& filename, InputArray img, const vector<int>& params)", "fname": "imwrite", "description": "Saves an image to a specified file."}]}}