{"function": {"cv": [{"return_type": "void", "pars": [{"description": " \u2013 Image where the circle is drawn.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Center of the circle.", "type": "Point", "name": "center"}, {"description": " \u2013 Radius of the circle.", "type": "int", "name": "radius"}, {"description": " \u2013 Circle color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of the circle outline, if positive. Negative thickness means that a filled circle is to be drawn.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the circle boundary. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the coordinates of the center and in the radius value.", "type": "int", "name": "shift"}], "fname": "circle", "description": "Draws a circle.", "name": "void circle(Mat& img, Point center, int radius, const Scalar& color, int thickness, int lineType, int shift)"}, {"return_type": "bool", "pars": [{"description": " \u2013 Image rectangle.", "type": "Rect", "name": "imgRect"}, {"description": " \u2013 First line point.", "type": "Point&", "name": "pt1"}, {"description": " \u2013 Second line point.", "type": "Point&", "name": "pt2"}], "fname": "clipLine", "description": "Clips the line against the image rectangle.", "name": "bool clipLine(Rect imgRect, Point& pt1, Point& pt2)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Text string to be drawn.", "type": "const string&", "name": "text"}, {"description": " \u2013 Bottom-left corner of the text string in the image.", "type": "Point", "name": "org"}, {"description": " \u2013 Font type. One of <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_SIMPLEX</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_PLAIN</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_DUPLEX</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_COMPLEX</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_TRIPLEX</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_COMPLEX_SMALL</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_SCRIPT_SIMPLEX</span></tt>, or <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_SCRIPT_COMPLEX</span></tt>, where each of the font ID\u2019s can be combined with <tt class=\"docutils literal\"><span class=\"pre\">FONT_HERSHEY_ITALIC</span></tt> to get the slanted letters.", "type": "int", "name": "fontFace"}, {"description": " \u2013 Font scale factor that is multiplied by the font-specific base size.", "type": "double", "name": "fontScale"}, {"description": " \u2013 Text color.", "type": "Scalar", "name": "color"}, {"description": " \u2013 Thickness of the lines used to draw a text.", "type": "int", "name": "thickness"}, {"description": " \u2013 Line type. See the <tt class=\"docutils literal\"><span class=\"pre\">line</span></tt> for details.", "type": "int", "name": "lineType"}, {"description": " \u2013 When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.", "type": "bool", "name": "bottomLeftOrigin"}], "fname": "putText", "description": "Draws a text string.", "name": "void putText(Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Array of polygonal curves.", "type": "const Point**", "name": "pts"}, {"description": " \u2013 Array of polygon vertex counters.", "type": "const int*", "name": "npts"}, {"description": " \u2013 Number of curves.", "type": "int", "name": "ncontours"}, {"description": " \u2013 Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex.", "type": "bool", "name": "isClosed"}, {"description": " \u2013 Polyline color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of the polyline edges.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the line segments. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the vertex coordinates.", "type": "int", "name": "shift"}], "fname": "polylines", "description": "Draws several polygonal curves.", "name": "void polylines(Mat& img, const Point** pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness, int lineType, int shift)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Center of the ellipse.", "type": "Point", "name": "center"}, {"description": " \u2013 Half of the size of the ellipse main axes.", "type": "Size", "name": "axes"}, {"description": " \u2013 Ellipse rotation angle in degrees.", "type": "double", "name": "angle"}, {"description": " \u2013 Starting angle of the elliptic arc in degrees.", "type": "double", "name": "startAngle"}, {"description": " \u2013 Ending angle of the elliptic arc in degrees.", "type": "double", "name": "endAngle"}, {"description": " \u2013 Ellipse color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the ellipse boundary. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the coordinates of the center and values of axes.", "type": "int", "name": "shift"}], "fname": "ellipse", "description": "Draws a simple or thick elliptic arc or fills an ellipse sector.", "name": "void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)"}, {"return_type": "Size", "pars": [{"description": " \u2013 Input text string.", "type": "const string&", "name": "text"}, {"description": " \u2013 Font description in terms of old C API.", "type": "int", "name": "fontFace"}, {"description": " \u2013 Font scale. See the <a class=\"reference internal\" href=\"#void putText(Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)\" title=\"void putText(Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">putText()</span></tt></a> for details.", "type": "double", "name": "fontScale"}, {"description": " \u2013 Thickness of lines used to render the text. See <a class=\"reference internal\" href=\"#void putText(Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)\" title=\"void putText(Mat& img, const string& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">putText()</span></tt></a> for details.", "type": "int", "name": "thickness"}, {"description": " \u2013 Output parameter - y-coordinate of the baseline relative to the bottom-most text point.", "type": "int*", "name": "baseLine"}], "fname": "getTextSize", "description": "Calculates the width and height of a text string.", "name": "Size getTextSize(const string& text, int fontFace, double fontScale, int thickness, int* baseLine)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "InputOutputArray", "name": "img"}, {"description": " \u2013 Array of polygonal curves.", "type": "InputArrayOfArrays", "name": "pts"}, {"description": " \u2013 Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex.", "type": "bool", "name": "isClosed"}, {"description": " \u2013 Polyline color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of the polyline edges.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the line segments. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the vertex coordinates.", "type": "int", "name": "shift"}], "fname": "polylines", "description": "Draws several polygonal curves.", "name": "void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar& color, int thickness, int lineType, int shift)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Alternative specification of the drawn rectangle.", "type": "Rect", "name": "rec"}, {"description": " \u2013 Rectangle color or brightness (grayscale image).", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of lines that make up the rectangle. Negative values, like <tt class=\"docutils literal\"><span class=\"pre\">CV_FILLED</span></tt> , mean that the function has to draw a filled rectangle.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the line. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the point coordinates.", "type": "int", "name": "shift"}], "fname": "LineIterator", "description": "Draws a simple, thick, or filled up-right rectangle.", "name": "void rectangle(Mat& img, Rect rec, const Scalar& color, int thickness, int lineType, int shift)"}, {"return_type": "void", "pars": [{"description": " \u2013 Center of the arc.", "type": "Point", "name": "center"}, {"description": " \u2013 Half of the size of the ellipse main axes. See the <a class=\"reference internal\" href=\"#void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">ellipse()</span></tt></a> for details.", "type": "Size", "name": "axes"}, {"description": " \u2013 Rotation angle of the ellipse in degrees. See the <a class=\"reference internal\" href=\"#void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">ellipse()</span></tt></a> for details.", "type": "int", "name": "angle"}, {"description": " \u2013 Starting angle of the elliptic arc in degrees.", "type": "int", "name": "arcStart"}, {"description": " \u2013 Ending angle of the elliptic arc in degrees.", "type": "int", "name": "arcEnd"}, {"description": " \u2013 Angle between the subsequent polyline vertices. It defines the approximation accuracy.", "type": "int", "name": "delta"}, {"description": " \u2013 Output vector of polyline vertices.", "type": "vector<Point>&", "name": "pts"}], "fname": "ellipse2Poly", "description": "Approximates an elliptic arc with a polyline.", "name": "void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector<Point>& pts)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Alternative ellipse representation via <a class=\"reference internal\" href=\"basic_structures.html#RotatedRect\" title=\"class RotatedRect\"><tt class=\"xref ocv ocv-class docutils literal\"><span class=\"pre\">RotatedRect</span></tt></a> or <tt class=\"docutils literal\"><span class=\"pre\">CvBox2D</span></tt>. This means that the function draws an ellipse inscribed in the rotated rectangle.", "type": "const RotatedRect&", "name": "box"}, {"description": " \u2013 Ellipse color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the ellipse boundary. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}], "fname": "ellipse", "description": "Draws a simple or thick elliptic arc or fills an ellipse sector.", "name": "void ellipse(Mat& img, const RotatedRect& box, const Scalar& color, int thickness, int lineType)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Vertex of the rectangle.", "type": "Point", "name": "pt1"}, {"description": " \u2013 Vertex of the rectangle opposite to <tt class=\"docutils literal\"><span class=\"pre\">pt1</span></tt> .", "type": "Point", "name": "pt2"}, {"description": " \u2013 Rectangle color or brightness (grayscale image).", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Thickness of lines that make up the rectangle. Negative values, like <tt class=\"docutils literal\"><span class=\"pre\">CV_FILLED</span></tt> , mean that the function has to draw a filled rectangle.", "type": "int", "name": "thickness"}, {"description": " \u2013 Type of the line. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the point coordinates.", "type": "int", "name": "shift"}], "fname": "LineIterator", "description": "Draws a simple, thick, or filled up-right rectangle.", "name": "void rectangle(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Polygon vertices.", "type": "const Point*", "name": "pts"}, {"description": " \u2013 Number of polygon vertices.", "type": "int", "name": "npts"}, {"description": " \u2013 Polygon color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Type of the polygon boundaries. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the vertex coordinates.", "type": "int", "name": "shift"}], "fname": "fillConvexPoly", "description": "Fills a convex polygon.", "name": "void fillConvexPoly(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType, int shift)"}, {"return_type": "void", "pars": [{"description": " \u2013 Image.", "type": "Mat&", "name": "img"}, {"description": " \u2013 Array of polygons where each polygon is represented as an array of points.", "type": "const Point**", "name": "pts"}, {"description": " \u2013 Array of polygon vertex counters.", "type": "const int*", "name": "npts"}, {"description": " \u2013 Number of contours that bind the filled region.", "type": "int", "name": "ncontours"}, {"description": " \u2013 Polygon color.", "type": "const Scalar&", "name": "color"}, {"description": " \u2013 Type of the polygon boundaries. See the <a class=\"reference internal\" href=\"#void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\" title=\"void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">line()</span></tt></a> description.", "type": "int", "name": "lineType"}, {"description": " \u2013 Number of fractional bits in the vertex coordinates.", "type": "int", "name": "shift"}, {"description": " \u2013 Optional offset of all points of the contours.", "type": "Point", "name": "offset"}], "fname": "fillPoly", "description": "Fills the area bounded by one or more polygons.", "name": "void fillPoly(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType, int shift, Point offset)"}, {"return_type": "bool", "pars": [{"description": " \u2013 Image size. The image rectangle is <tt class=\"docutils literal\"><span class=\"pre\">Rect(0,</span> <span class=\"pre\">0,</span> <span class=\"pre\">imgSize.width,</span> <span class=\"pre\">imgSize.height)</span></tt> .", "type": "Size", "name": "imgSize"}, {"description": " \u2013 First line point.", "type": "Point&", "name": "pt1"}, {"description": " \u2013 Second line point.", "type": "Point&", "name": "pt2"}], "fname": "clipLine", "description": "Clips the line against the image rectangle.", "name": "bool clipLine(Size imgSize, Point& pt1, Point& pt2)"}]}}