{"function": {"cv": [{"pars": [{"description": " \u2013 The written frame", "name": "image", "type": "const Mat&"}], "fname": "ReleaseVideoWriter", "description": "Releases the AVI writer.", "return_type": "void", "name": "void VideoWriter::write(const Mat& image)"}, {"pars": [{"description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "name": "filename", "type": "const string&"}], "fname": "VideoCapture", "description": "VideoCapture constructors.", "return_type": "non-return-type", "name": "VideoCapture::VideoCapture(const string& filename)"}, {"pars": [], "fname": "ReleaseVideoWriter", "description": "Releases the AVI writer.", "return_type": "non-return-type", "name": "VideoWriter& VideoWriter::operator << (const Mat& image)"}, {"pars": [{"description": " \u2013 Input array or vector of bytes.", "name": "buf", "type": "InputArray"}, {"description": " \u2013 The same flags as in <a class=\"reference internal\" href=\"#Mat imread(const string& filename, int flags)\" title=\"Mat imread(const string& filename, int flags)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imread()</span></tt></a> .", "name": "flags", "type": "int"}], "fname": "imdecode", "description": "Reads an image from a buffer in memory.", "return_type": "Mat", "name": "Mat imdecode(InputArray buf, int flags)"}, {"pars": [], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "bool", "name": "bool VideoCapture::isOpened()"}, {"pars": [{"description": null, "name": "propId", "type": "int"}], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "double", "name": "double VideoCapture::get(int propId)"}, {"pars": [], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "void", "name": "void VideoCapture::release()"}, {"pars": [{"description": null, "name": "filename", "type": "const string&"}, {"description": null, "name": "fourcc", "type": "int"}, {"description": null, "name": "fps", "type": "double"}, {"description": null, "name": "frameSize", "type": "Size"}, {"description": null, "name": "isColor", "type": "bool"}], "fname": "ReleaseVideoWriter", "description": "Releases the AVI writer.", "return_type": "bool", "name": "bool VideoWriter::open(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)"}, {"pars": [{"description": " \u2013 <p>Property identifier. It can be one of the following:</p> <ul> <li><strong>CV_CAP_PROP_POS_MSEC</strong> Current position of the video file in milliseconds.", "name": "propId", "type": "int"}, {"description": " \u2013 Value of the property.", "name": "value", "type": "double"}], "fname": "VideoCapture::set", "description": "Sets a property in the <tt class=\"docutils literal\"><span class=\"pre\">VideoCapture</span></tt>.", "return_type": "bool", "name": "bool VideoCapture::set(int propId, double value)"}, {"pars": [], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "bool", "name": "bool VideoCapture::grab()"}, {"pars": [], "fname": "VideoWriter", "description": "VideoWriter constructors", "return_type": "non-return-type", "name": "VideoWriter::VideoWriter()"}, {"pars": [{"description": null, "name": "image", "type": "Mat&"}], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "bool", "name": "bool VideoCapture::read(Mat& image)"}, {"pars": [], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "non-return-type", "name": "VideoCapture& VideoCapture::operator >> (Mat& image)"}, {"pars": [], "fname": "VideoCapture", "description": "VideoCapture constructors.", "return_type": "non-return-type", "name": "VideoCapture::VideoCapture()"}, {"pars": [{"description": " \u2013 name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)", "name": "filename", "type": "const string&"}], "fname": "VideoCapture::open", "description": "Open video file or a capturing device for video capturing", "return_type": "bool", "name": "bool VideoCapture::open(const string& filename)"}, {"pars": [{"description": " \u2013 Name of file to be loaded.", "name": "filename", "type": "const string&"}, {"description": " \u2013 <p>Flags specifying the color type of a loaded image:</p> <ul> <li>CV_LOAD_IMAGE_ANYDEPTH - If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.", "name": "flags", "type": "int"}], "fname": "imread", "description": "Loads an image from a file.", "return_type": "Mat", "name": "Mat imread(const string& filename, int flags)"}, {"pars": [{"description": " \u2013 Name of the output video file.", "name": "filename", "type": "const string&"}, {"description": " \u2013 4-character code of codec used to compress the frames. For example, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('P','I','M','1')</span></tt> is a MPEG-1 codec, <tt class=\"docutils literal\"><span class=\"pre\">CV_FOURCC('M','J','P','G')</span></tt> is a motion-jpeg codec etc. List of codes can be obtained at <a class=\"reference external\" href=\"http://www.fourcc.org/codecs.php\">Video Codecs by FOURCC</a> page.", "name": "fourcc", "type": "int"}, {"description": " \u2013 Framerate of the created video stream.", "name": "fps", "type": "double"}, {"description": " \u2013 Size of the video frames.", "name": "frameSize", "type": "Size"}, {"description": " \u2013 If it is not zero, the encoder will expect and encode color frames, otherwise it will work with grayscale frames (the flag is currently supported on Windows only).", "name": "isColor", "type": "bool"}], "fname": "VideoWriter", "description": "VideoWriter constructors", "return_type": "non-return-type", "name": "VideoWriter::VideoWriter(const string& filename, int fourcc, double fps, Size frameSize, bool isColor)"}, {"pars": [], "fname": "ReleaseVideoWriter", "description": "Releases the AVI writer.", "return_type": "bool", "name": "bool VideoWriter::isOpened()"}, {"pars": [{"description": " \u2013 Name of the file.", "name": "filename", "type": "const string&"}, {"description": null, "name": "img", "type": "InputArray"}, {"description": " \u2013 <p>Format-specific save parameters encoded as pairs <tt class=\"docutils literal\"><span class=\"pre\">paramId_1,</span> <span class=\"pre\">paramValue_1,</span> <span class=\"pre\">paramId_2,</span> <span class=\"pre\">paramValue_2,</span> <span class=\"pre\">...</span></tt> . The following parameters are currently supported:</p> <ul> <li>For JPEG, it can be a quality ( <tt class=\"docutils literal\"><span class=\"pre\">CV_IMWRITE_JPEG_QUALITY</span></tt> ) from 0 to 100 (the higher is the better). Default value is 95.", "name": "params", "type": "const vector<int>&"}], "fname": "imwrite", "description": "Saves an image to a specified file.", "return_type": "bool", "name": "bool imwrite(const string& filename, InputArray img, const vector<int>& params)"}, {"pars": [{"description": " \u2013 Input array or vector of bytes.", "name": "buf", "type": "InputArray"}, {"description": " \u2013 The same flags as in <a class=\"reference internal\" href=\"#Mat imread(const string& filename, int flags)\" title=\"Mat imread(const string& filename, int flags)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imread()</span></tt></a> .", "name": "flags", "type": "int"}, {"description": " \u2013 The optional output placeholder for the decoded matrix. It can save the image reallocations when the function is called repeatedly for images of the same size.", "name": "dst", "type": "Mat*"}], "fname": "imdecode", "description": "Reads an image from a buffer in memory.", "return_type": "Mat", "name": "Mat imdecode(InputArray buf, int flags, Mat* dst)"}, {"pars": [{"description": " \u2013 id of the opened video capturing device (i.e. a camera index).", "name": "device", "type": "int"}], "fname": "VideoCapture::open", "description": "Open video file or a capturing device for video capturing", "return_type": "bool", "name": "bool VideoCapture::open(int device)"}, {"pars": [{"description": " \u2013 id of the opened video capturing device (i.e. a camera index). If there is a single camera connected, just pass 0.", "name": "device", "type": "int"}], "fname": "VideoCapture", "description": "VideoCapture constructors.", "return_type": "non-return-type", "name": "VideoCapture::VideoCapture(int device)"}, {"pars": [{"description": null, "name": "image", "type": "Mat&"}, {"description": null, "name": "channel", "type": "int"}], "fname": "VideoCapture::isOpened", "description": "Returns true if video capturing has been initialized already.", "return_type": "bool", "name": "bool VideoCapture::retrieve(Mat& image, int channel)"}, {"pars": [{"description": " \u2013 File extension that defines the output format.", "name": "ext", "type": "const string&"}, {"description": " \u2013 Image to be written.", "name": "img", "type": "InputArray"}, {"description": " \u2013 Output buffer resized to fit the compressed image.", "name": "buf", "type": "vector<uchar>&"}, {"description": " \u2013 Format-specific parameters. See <a class=\"reference internal\" href=\"#bool imwrite(const string& filename, InputArray img, const vector<int>& params)\" title=\"bool imwrite(const string& filename, InputArray img, const vector<int>& params)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">imwrite()</span></tt></a> .", "name": "params", "type": "const vector<int>&"}], "fname": "imencode", "description": "Encodes an image into a memory buffer.", "return_type": "bool", "name": "bool imencode(const string& ext, InputArray img, vector<uchar>& buf, const vector<int>& params)"}]}}