{"function": {"cv": [{"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 Source image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 Destination image of the same type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> and the size <tt class=\"docutils literal\"><span class=\"pre\">Size(src.cols+left+right,</span> <span class=\"pre\">src.rows+top+bottom)</span></tt> ."}, {"type": "int", "name": "top", "description": " \u2013 "}, {"type": "int", "name": "bottom", "description": " \u2013 "}, {"type": "int", "name": "left", "description": " \u2013 "}, {"type": "int", "name": "right", "description": " \u2013 Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, <tt class=\"docutils literal\"><span class=\"pre\">top=1,</span> <span class=\"pre\">bottom=1,</span> <span class=\"pre\">left=1,</span> <span class=\"pre\">right=1</span></tt> mean that 1 pixel-wide border needs to be built."}, {"type": "int", "name": "borderType", "description": " \u2013 Border type. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details."}, {"type": "const Scalar&", "name": "value", "description": " \u2013 Border value if <tt class=\"docutils literal\"><span class=\"pre\">borderType==BORDER_CONSTANT</span></tt> ."}], "name": "void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value)", "description": "Forms a border around an image.", "fname": "copyMakeBorder", "return_type": "void"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source image type."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "int", "name": "dx", "description": " \u2013 Derivative order in respect of x."}, {"type": "int", "name": "dy", "description": " \u2013 Derivative order in respect of y."}, {"type": "int", "name": "ksize", "description": " \u2013 Aperture size See <a class=\"reference internal\" href=\"#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\" title=\"void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getDerivKernels()</span></tt></a> ."}, {"type": "int", "name": "borderType", "description": " \u2013 Border type to use. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "name": "Ptr<FilterEngine> createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, int borderType)", "description": "Returns an engine for computing image derivatives.", "fname": "createDerivFilter", "return_type": "Ptr<FilterEngine>"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image; the image can have any number of channels, which are processed independently, but the depth should be <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "Size", "name": "ksize", "description": " \u2013 Gaussian kernel size. <tt class=\"docutils literal\"><span class=\"pre\">ksize.width</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ksize.height</span></tt> can differ but they both must be positive and odd. Or, they can be zero\u2019s and then they are computed from <tt class=\"docutils literal\"><span class=\"pre\">sigma*</span></tt> ."}, {"type": "double", "name": "sigmaX", "description": " \u2013 Gaussian kernel standard deviation in X direction."}, {"type": "double", "name": "sigmaY", "description": " \u2013 Gaussian kernel standard deviation in Y direction; if <tt class=\"docutils literal\"><span class=\"pre\">sigmaY</span></tt> is zero, it is set to be equal to <tt class=\"docutils literal\"><span class=\"pre\">sigmaX</span></tt>, if both sigmas are zeros, they are computed from <tt class=\"docutils literal\"><span class=\"pre\">ksize.width</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ksize.height</span></tt> , respectively (see <a class=\"reference internal\" href=\"#Mat getGaussianKernel(int ksize, double sigma, int ktype)\" title=\"Mat getGaussianKernel(int ksize, double sigma, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getGaussianKernel()</span></tt></a> for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of <tt class=\"docutils literal\"><span class=\"pre\">ksize</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">sigmaX</span></tt>, and <tt class=\"docutils literal\"><span class=\"pre\">sigmaY</span></tt>."}, {"type": "int", "name": "borderType", "description": " \u2013 pixel extrapolation method (see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details)."}], "name": "void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)", "description": "Blurs an image using a Gaussian filter.", "fname": "GaussianBlur", "return_type": "void"}, {"pars": [{"type": "int", "name": "shape", "description": " \u2013 <p>Element shape that could be one of the following:</p> <ul> <li><strong>MORPH_RECT</strong> - a rectangular structuring element:<div class=\"math\"> <p><img src=\"../../../_images/math/8e98ec0adad5d21e9a5607e42466e4b04ea9ac53.png\" alt=\"E_{ij}=1\"/></p> </div>"}, {"type": "Size", "name": "ksize", "description": " \u2013 Size of the structuring element."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position within the element. The default value <img class=\"math\" src=\"../../../_images/math/6155e28d15217ab6e8ea537771fdce74d647ed6e.png\" alt=\"(-1, -1)\"/> means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted."}], "name": "Mat getStructuringElement(int shape, Size ksize, Point anchor)", "description": "Returns a structuring element of the specified size and shape for morphological operations.", "fname": "getStructuringElement", "return_type": "Mat"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 The source image"}, {"type": "OutputArray", "name": "dst", "description": " \u2013 The destination image; will have the same size and the same type as src"}, {"type": "Size", "name": "ksize", "description": " \u2013 The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner)."}, {"type": "double", "name": "sigmaSpace", "description": " \u2013 Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d>0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace."}, {"type": "double maxSigmaColor", "name": "", "description": null}, {"type": "Point", "name": "anchor", "description": null}, {"type": "int", "name": "borderType", "description": " \u2013 Pixel extrapolation method."}], "name": "void adaptiveBilateralFilter(InputArray src, OutputArray dst, Size ksize, double sigmaSpace, double maxSigmaColor , Point anchor, int borderType)", "description": "Applies the adaptive bilateral filter to an image.", "fname": "adaptiveBilateralFilter", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image; the number of channels can be arbitrary, but the depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "InputArray", "name": "kernel", "description": null}, {"type": "Point", "name": "anchor", "description": " \u2013 position of the anchor within the element; default value <tt class=\"docutils literal\"><span class=\"pre\">(-1,</span> <span class=\"pre\">-1)</span></tt> means that the anchor is at the element center."}, {"type": "int", "name": "iterations", "description": " \u2013 number of times erosion is applied."}, {"type": "int", "name": "borderType", "description": " \u2013 pixel extrapolation method (see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details)."}, {"type": "const Scalar&", "name": "borderValue", "description": " \u2013 border value in case of a constant border (see <a class=\"reference internal\" href=\"#Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)\" title=\"Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">createMorphologyFilter()</span></tt></a> for details)."}], "name": "void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)", "description": "Erodes an image by using a specific structuring element.", "fname": "erode", "return_type": "void"}, {"pars": [{"type": "int", "name": "op", "description": " \u2013 Morphology operation ID, <tt class=\"docutils literal\"><span class=\"pre\">MORPH_ERODE</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">MORPH_DILATE</span></tt> ."}, {"type": "int", "name": "type", "description": " \u2013 Input/output image type. The number of channels can be arbitrary. The depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "InputArray", "name": "kernel", "description": " \u2013 2D 8-bit structuring element for a morphological operation. Non-zero elements indicate the pixels that belong to the element."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position within the structuring element. Negative values mean that the anchor is at the kernel center."}, {"type": "int", "name": "rowBorderType", "description": " \u2013 Pixel extrapolation method in the vertical direction. For details, see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a>."}, {"type": "int", "name": "columnBorderType", "description": " \u2013 Pixel extrapolation method in the horizontal direction."}, {"type": "const Scalar&", "name": "borderValue", "description": " \u2013 Border value in case of a constant border. The default value, <tt class=\"docutils literal\"><span class=\"pre\">morphologyDefaultBorderValue</span></tt> , has a special meaning. It is transformed <img class=\"math\" src=\"../../../_images/math/8395ffd7fd9152687dbf5272cbb73294b3b52615.png\" alt=\"+\\inf\"/> for the erosion and to <img class=\"math\" src=\"../../../_images/math/e1b7928b9f62af38ffcb69c44d8f32c60d24114d.png\" alt=\"-\\inf\"/> for the dilation, which means that the minimum (maximum) is effectively computed only over the pixels that are inside the image."}], "name": "Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)", "description": "Creates an engine for non-separable morphological operations.", "fname": "createMorphologyFilter", "return_type": "Ptr<FilterEngine>"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image; the number of channels can be arbitrary, but the depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "InputArray", "name": "kernel", "description": null}, {"type": "Point", "name": "anchor", "description": " \u2013 position of the anchor within the element; default value <tt class=\"docutils literal\"><span class=\"pre\">(-1,</span> <span class=\"pre\">-1)</span></tt> means that the anchor is at the element center."}, {"type": "int", "name": "iterations", "description": " \u2013 number of times dilation is applied."}, {"type": "int", "name": "borderType", "description": " \u2013 pixel extrapolation method (see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details)."}, {"type": "const Scalar&", "name": "borderValue", "description": " \u2013 border value in case of a constant border (see <a class=\"reference internal\" href=\"#Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)\" title=\"Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">createMorphologyFilter()</span></tt></a> for details)."}], "name": "void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)", "description": "Dilates an image by using a specific structuring element.", "fname": "dilate", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and the same number of channels as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "int", "name": "ddepth", "description": " \u2013 <dl class=\"docutils\"> <dt>desired depth of the destination image; if it is negative, it will be the same as <tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt>; the following combinations of <tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt> are supported:</dt> <dd><ul class=\"first last\"> <li><tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> = <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt> = -1/<tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>/<tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>/<tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>"}, {"type": "InputArray", "name": "kernel", "description": " \u2013 convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using <a class=\"reference internal\" href=\"../../core/doc/operations_on_arrays.html#void split(const Mat& src, Mat* mvbegin)\" title=\"void split(const Mat& src, Mat* mvbegin)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">split()</span></tt></a> and process them individually."}, {"type": "Point", "name": "anchor", "description": " \u2013 anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center."}, {"type": "double", "name": "delta", "description": " \u2013 optional value added to the filtered pixels before storing them in <tt class=\"docutils literal\"><span class=\"pre\">dst</span></tt>."}, {"type": "int", "name": "borderType", "description": " \u2013 pixel extrapolation method (see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details)."}], "name": "void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)", "description": "Convolves an image with the kernel.", "fname": "filter2D", "return_type": "void"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source image type."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "Size", "name": "ksize", "description": " \u2013 Aperture size."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position with the kernel. Negative values mean that the anchor is at the kernel center."}, {"type": "bool", "name": "normalize", "description": " \u2013 Flag specifying whether the sums are normalized or not. See <a class=\"reference internal\" href=\"#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)\" title=\"void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">boxFilter()</span></tt></a> for details."}, {"type": "int", "name": "borderType", "description": " \u2013 Border type to use. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "name": "Ptr<FilterEngine> createBoxFilter(int srcType, int dstType, Size ksize, Point anchor, bool normalize, int borderType)", "description": "Returns a box filter engine.", "fname": "createBoxFilter", "return_type": "Ptr<FilterEngine>"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source image type."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "InputArray", "name": "kernel", "description": " \u2013 2D array of filter coefficients."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor point within the kernel. Special value <tt class=\"docutils literal\"><span class=\"pre\">Point(-1,-1)</span></tt> means that the anchor is at the kernel center."}, {"type": "double", "name": "delta", "description": " \u2013 Value added to the filtered results before storing them."}, {"type": "int", "name": "bits", "description": " \u2013 Number of the fractional bits. The parameter is used when the kernel is an integer matrix representing fixed-point filter coefficients."}], "name": "Ptr<BaseFilter> getLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor, double delta, int bits)", "description": "Creates a non-separable linear filter engine.", "fname": "createLinearFilter", "return_type": "Ptr<BaseFilter>"}, {"pars": [{"type": "int", "name": "p", "description": " \u2013 0-based coordinate of the extrapolated pixel along one of the axes, likely <0 or >= <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt> ."}, {"type": "int", "name": "len", "description": " \u2013 Length of the array along the corresponding axis."}, {"type": "int", "name": "borderType", "description": " \u2013 Border type, one of the <tt class=\"docutils literal\"><span class=\"pre\">BORDER_*</span></tt> , except for <tt class=\"docutils literal\"><span class=\"pre\">BORDER_TRANSPARENT</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">BORDER_ISOLATED</span></tt> . When <tt class=\"docutils literal\"><span class=\"pre\">borderType==BORDER_CONSTANT</span></tt> , the function always returns -1, regardless of <tt class=\"docutils literal\"><span class=\"pre\">p</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">len</span></tt> ."}], "name": "int borderInterpolate(int p, int len, int borderType)", "description": "Computes the source location of an extrapolated pixel.", "fname": "borderInterpolate", "return_type": "int"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 The color window radius."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 The destination image of the same format and the same size as the source."}, {"type": "double", "name": "sp", "description": " \u2013 The spatial window radius."}, {"type": "double", "name": "sr", "description": null}, {"type": "int", "name": "maxLevel", "description": " \u2013 Maximum level of the pyramid for the segmentation."}, {"type": "TermCriteria", "name": "termcrit", "description": " \u2013 Termination criteria: when to stop meanshift iterations."}], "name": "void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)", "description": "Performs initial step of meanshift segmentation of an image.", "fname": "pyrMeanShiftFiltering", "return_type": "void"}, {"pars": [{"type": "int", "name": "sumType", "description": " \u2013 Intermediate horizontal sum type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "int", "name": "ksize", "description": " \u2013 Aperture size."}, {"type": "int", "name": "anchor", "description": " \u2013 Anchor position with the kernel. Negative values mean that the anchor is at the kernel center."}, {"type": "double", "name": "scale", "description": " \u2013 Another way to specify normalization in lower-level <tt class=\"docutils literal\"><span class=\"pre\">getColumnSumFilter</span></tt> ."}], "name": "Ptr<BaseColumnFilter> getColumnSumFilter(int sumType, int dstType, int ksize, int anchor, double scale)", "description": "Returns a box filter engine.", "fname": "createBoxFilter", "return_type": "Ptr<BaseColumnFilter>"}, {"pars": [{"type": "OutputArray", "name": "kx", "description": " \u2013 Output matrix of row filter coefficients. It has the type <tt class=\"docutils literal\"><span class=\"pre\">ktype</span></tt> ."}, {"type": "OutputArray", "name": "ky", "description": " \u2013 Output matrix of column filter coefficients. It has the type <tt class=\"docutils literal\"><span class=\"pre\">ktype</span></tt> ."}, {"type": "int", "name": "dx", "description": " \u2013 Derivative order in respect of x."}, {"type": "int", "name": "dy", "description": " \u2013 Derivative order in respect of y."}, {"type": "int", "name": "ksize", "description": " \u2013 Aperture size. It can be <tt class=\"docutils literal\"><span class=\"pre\">CV_SCHARR</span></tt> , 1, 3, 5, or 7."}, {"type": "bool", "name": "normalize", "description": " \u2013 Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator <img class=\"math\" src=\"../../../_images/math/5275ad994c6bbf00b138a583d217cd73b8eae957.png\" alt=\"=2^{ksize*2-dx-dy-2}\"/> . If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set <tt class=\"docutils literal\"><span class=\"pre\">normalize=false</span></tt> ."}, {"type": "int", "name": "ktype", "description": " \u2013 Type of filter coefficients. It can be <tt class=\"docutils literal\"><span class=\"pre\">CV_32f</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt> ."}], "name": "void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)", "description": "Returns filter coefficients for computing spatial image derivatives.", "fname": "getDerivKernels", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image; it can have any number of channels, which are processed independently, but the depth should be <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "Size", "name": "ksize", "description": " \u2013 blurring kernel size."}, {"type": "Point", "name": "anchor", "description": " \u2013 anchor point; default value <tt class=\"docutils literal\"><span class=\"pre\">Point(-1,-1)</span></tt> means that the anchor is at the kernel center."}, {"type": "int", "name": "borderType", "description": " \u2013 border mode used to extrapolate pixels outside of the image."}], "name": "void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)", "description": "Blurs an image using the normalized box filter.", "fname": "blur", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 Source 8-bit or floating-point, 1-channel or 3-channel image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from <tt class=\"docutils literal\"><span class=\"pre\">sigmaSpace</span></tt> ."}, {"type": "int", "name": "d", "description": null}, {"type": "double", "name": "sigmaColor", "description": " \u2013 Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see <tt class=\"docutils literal\"><span class=\"pre\">sigmaSpace</span></tt> ) will be mixed together, resulting in larger areas of semi-equal color."}, {"type": "double", "name": "sigmaSpace", "description": " \u2013 Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see <tt class=\"docutils literal\"><span class=\"pre\">sigmaColor</span></tt> ). When <tt class=\"docutils literal\"><span class=\"pre\">d>0</span></tt> , it specifies the neighborhood size regardless of <tt class=\"docutils literal\"><span class=\"pre\">sigmaSpace</span></tt> . Otherwise, <tt class=\"docutils literal\"><span class=\"pre\">d</span></tt> is proportional to <tt class=\"docutils literal\"><span class=\"pre\">sigmaSpace</span></tt> ."}, {"type": "int", "name": "borderType", "description": null}], "name": "void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)", "description": "Applies the bilateral filter to an image.", "fname": "BaseColumnFilter", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "int", "name": "ddepth", "description": " \u2013 the output image depth (-1 to use <tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt>)."}, {"type": "Size", "name": "ksize", "description": " \u2013 blurring kernel size."}, {"type": "Point", "name": "anchor", "description": " \u2013 anchor point; default value <tt class=\"docutils literal\"><span class=\"pre\">Point(-1,-1)</span></tt> means that the anchor is at the kernel center."}, {"type": "bool", "name": "normalize", "description": " \u2013 flag, specifying whether the kernel is normalized by its area or not."}, {"type": "int", "name": "borderType", "description": " \u2013 border mode used to extrapolate pixels outside of the image."}], "name": "void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)", "description": "Blurs an image using the box filter.", "fname": "boxFilter", "return_type": "void"}, {"pars": [{"type": "int", "name": "type", "description": " \u2013 Source and destination image type."}, {"type": "Size", "name": "ksize", "description": " \u2013 Aperture size. See <a class=\"reference internal\" href=\"#Mat getGaussianKernel(int ksize, double sigma, int ktype)\" title=\"Mat getGaussianKernel(int ksize, double sigma, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getGaussianKernel()</span></tt></a> ."}, {"type": "double", "name": "sigma1", "description": " \u2013 Gaussian sigma in the horizontal direction. See <a class=\"reference internal\" href=\"#Mat getGaussianKernel(int ksize, double sigma, int ktype)\" title=\"Mat getGaussianKernel(int ksize, double sigma, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getGaussianKernel()</span></tt></a> ."}, {"type": "double", "name": "sigma2", "description": " \u2013 Gaussian sigma in the vertical direction. If 0, then <img class=\"math\" src=\"../../../_images/math/dd1c9db63c3e4e55f39a1f19a6dd77179cdbe104.png\" alt=\"\\texttt{sigma2}\\leftarrow\\texttt{sigma1}\"/> ."}, {"type": "int", "name": "borderType", "description": " \u2013 Border type to use. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "name": "Ptr<FilterEngine> createGaussianFilter(int type, Size ksize, double sigma1, double sigma2, int borderType)", "description": "Returns an engine for smoothing images with the Gaussian filter.", "fname": "createGaussianFilter", "return_type": "Ptr<FilterEngine>"}, {"pars": [], "name": "Scalar morphologyDefaultBorderValue()", "description": "Creates an engine for non-separable morphological operations.", "fname": "createMorphologyFilter", "return_type": "Scalar"}, {"pars": [{"type": "int", "name": "op", "description": " \u2013 Morphology operation ID, <tt class=\"docutils literal\"><span class=\"pre\">MORPH_ERODE</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">MORPH_DILATE</span></tt> ."}, {"type": "int", "name": "type", "description": " \u2013 Input/output image type. The number of channels can be arbitrary. The depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "int", "name": "ksize", "description": " \u2013 Horizontal or vertical structuring element size for separable morphological operations."}, {"type": "int", "name": "anchor", "description": " \u2013 Anchor position within the structuring element. Negative values mean that the anchor is at the kernel center."}], "name": "Ptr<BaseColumnFilter> getMorphologyColumnFilter(int op, int type, int ksize, int anchor)", "description": "Creates an engine for non-separable morphological operations.", "fname": "createMorphologyFilter", "return_type": "Ptr<BaseColumnFilter>"}, {"pars": [{"type": "InputArray", "name": "kernel", "description": " \u2013 1D array of the kernel coefficients to analyze."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position within the kernel."}], "name": "int getKernelType(InputArray kernel, Point anchor)", "description": "Returns the kernel type.", "fname": "getKernelType", "return_type": "int"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source array type."}, {"type": "int", "name": "bufType", "description": " \u2013 Intermediate buffer type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "InputArray", "name": "kernel", "description": null}, {"type": "int", "name": "anchor", "description": " \u2013 Anchor position within the kernel. Negative values mean that anchor is positioned at the aperture center."}, {"type": "int", "name": "symmetryType", "description": " \u2013 Type of each row and column kernel. See <a class=\"reference internal\" href=\"#int getKernelType(InputArray kernel, Point anchor)\" title=\"int getKernelType(InputArray kernel, Point anchor)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getKernelType()</span></tt></a> ."}], "name": "Ptr<BaseRowFilter> getLinearRowFilter(int srcType, int bufType, InputArray kernel, int anchor, int symmetryType)", "description": "Creates an engine for a separable linear filter.", "fname": "createSeparableLinearFilter", "return_type": "Ptr<BaseRowFilter>"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 Source image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 Destination image of the same size and the same number of channels as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"type": "int", "name": "ddepth", "description": " \u2013 <dl class=\"docutils\"> <dt>Destination image depth. The following combination of <tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt> are supported:</dt> <dd><ul class=\"first last\"> <li><tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> = <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt> = -1/<tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>/<tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>/<tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>"}, {"type": "InputArray", "name": "kernelX", "description": " \u2013 Coefficients for filtering each row."}, {"type": "InputArray", "name": "kernelY", "description": " \u2013 Coefficients for filtering each column."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position within the kernel. The default value <img class=\"math\" src=\"../../../_images/math/a11af309f4f98a632b52d2972cd9de92053c603c.png\" alt=\"(-1,-1)\"/> means that the anchor is at the kernel center."}, {"type": "double", "name": "delta", "description": " \u2013 Value added to the filtered results before storing them."}, {"type": "int", "name": "borderType", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details."}], "name": "void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)", "description": "Applies a separable linear filter to an image.", "fname": "sepFilter2D", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image; it has the specified size and the same type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "const Size&", "name": "dstsize", "description": " \u2013 <p>size of the output image; by default, it is computed as <tt class=\"docutils literal\"><span class=\"pre\">Size((src.cols+1)/2,</span> <span class=\"pre\">(src.rows+1)/2)</span></tt>, but in any case, the following conditions should be satisfied:</p> <div class=\"math\"> <p><img src=\"../../../_images/math/f1ab44981e9308163296424a1aa1d29a110a714d.png\" alt=\"\\begin{array}{l} | \\texttt{dstsize.width} *2-src.cols| \\leq 2 \\\\ | \\texttt{dstsize.height} *2-src.rows| \\leq 2 \\end{array}\"/></p> </div>"}, {"type": "int", "name": "borderType", "description": null}], "name": "void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)", "description": "Blurs an image and downsamples it.", "fname": "pyrDown", "return_type": "void"}, {"pars": [{"type": "int", "name": "op", "description": " \u2013 Morphology operation ID, <tt class=\"docutils literal\"><span class=\"pre\">MORPH_ERODE</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">MORPH_DILATE</span></tt> ."}, {"type": "int", "name": "type", "description": " \u2013 Input/output image type. The number of channels can be arbitrary. The depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "InputArray", "name": "kernel", "description": " \u2013 2D 8-bit structuring element for a morphological operation. Non-zero elements indicate the pixels that belong to the element."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position within the structuring element. Negative values mean that the anchor is at the kernel center."}], "name": "Ptr<BaseFilter> getMorphologyFilter(int op, int type, InputArray kernel, Point anchor)", "description": "Creates an engine for non-separable morphological operations.", "fname": "createMorphologyFilter", "return_type": "Ptr<BaseFilter>"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 Source image. The number of channels can be arbitrary. The depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 Destination image of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"type": "int", "name": "op", "description": " \u2013 <p>Type of a morphological operation that can be one of the following:</p> <ul> <li><strong>MORPH_OPEN</strong> - an opening operation"}, {"type": "InputArray", "name": "kernel", "description": null}, {"type": "Point", "name": "anchor", "description": null}, {"type": "int", "name": "iterations", "description": " \u2013 Number of times erosion and dilation are applied."}, {"type": "int", "name": "borderType", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details."}, {"type": "const Scalar&", "name": "borderValue", "description": " \u2013 Border value in case of a constant border. The default value has a special meaning. See <a class=\"reference internal\" href=\"#Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)\" title=\"Ptr<FilterEngine> createMorphologyFilter(int op, int type, InputArray kernel, Point anchor, int rowBorderType, int columnBorderType, const Scalar& borderValue)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">createMorphologyFilter()</span></tt></a> for details."}], "name": "void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)", "description": "Performs advanced morphological transformations.", "fname": "morphologyEx", "return_type": "void"}, {"pars": [{"type": "int", "name": "bufType", "description": " \u2013 Intermediate buffer type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "InputArray", "name": "kernel", "description": null}, {"type": "int", "name": "anchor", "description": " \u2013 Anchor position within the kernel. Negative values mean that anchor is positioned at the aperture center."}, {"type": "int", "name": "symmetryType", "description": " \u2013 Type of each row and column kernel. See <a class=\"reference internal\" href=\"#int getKernelType(InputArray kernel, Point anchor)\" title=\"int getKernelType(InputArray kernel, Point anchor)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getKernelType()</span></tt></a> ."}, {"type": "double", "name": "delta", "description": " \u2013 Value added to the filtered results before storing them."}, {"type": "int", "name": "bits", "description": " \u2013 Number of the fractional bits. The parameter is used when the kernel is an integer matrix representing fixed-point filter coefficients."}], "name": "Ptr<BaseColumnFilter> getLinearColumnFilter(int bufType, int dstType, InputArray kernel, int anchor, int symmetryType, double delta, int bits)", "description": "Creates an engine for a separable linear filter.", "fname": "createSeparableLinearFilter", "return_type": "Ptr<BaseColumnFilter>"}, {"pars": [{"type": "int", "name": "ksize", "description": " \u2013 Aperture size. It should be odd ( <img class=\"math\" src=\"../../../_images/math/091d406a3ab6146e1fea3ca1b7b6598d5d6c0d8f.png\" alt=\"\\texttt{ksize} \\mod 2 = 1\"/> ) and positive."}, {"type": "double", "name": "sigma", "description": " \u2013 Gaussian standard deviation. If it is non-positive, it is computed from <tt class=\"docutils literal\"><span class=\"pre\">ksize</span></tt> as <tt class=\"docutils literal\"><span class=\"pre\">sigma</span> <span class=\"pre\">=</span> <span class=\"pre\">0.3*((ksize-1)*0.5</span> <span class=\"pre\">-</span> <span class=\"pre\">1)</span> <span class=\"pre\">+</span> <span class=\"pre\">0.8</span></tt> ."}, {"type": "int", "name": "ktype", "description": " \u2013 Type of filter coefficients. It can be <tt class=\"docutils literal\"><span class=\"pre\">CV_32f</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt> ."}], "name": "Mat getGaussianKernel(int ksize, double sigma, int ktype)", "description": "Returns Gaussian filter coefficients.", "fname": "getGaussianKernel", "return_type": "Mat"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and the same number of channels as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"type": "int", "name": "ddepth", "description": " \u2013 <dl class=\"docutils\"> <dt>output image depth; the following combinations of <tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt> are supported:</dt> <dd><ul class=\"first last\"> <li><tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> = <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt> = -1/<tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>/<tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>/<tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>"}, {"type": "int", "name": "dx", "description": null}, {"type": "int", "name": "dy", "description": null}, {"type": "int", "name": "ksize", "description": " \u2013 size of the extended Sobel kernel; it must be 1, 3, 5, or 7."}, {"type": "double", "name": "scale", "description": " \u2013 optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class=\"reference internal\" href=\"#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\" title=\"void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getDerivKernels()</span></tt></a> for details)."}, {"type": "double", "name": "delta", "description": " \u2013 optional delta value that is added to the results prior to storing them in <tt class=\"docutils literal\"><span class=\"pre\">dst</span></tt>."}, {"type": "int", "name": "borderType", "description": " \u2013 pixel extrapolation method (see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details)."}], "name": "void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)", "description": "Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.", "fname": "Sobel", "return_type": "void"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source image type."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "InputArray", "name": "kernel", "description": " \u2013 2D array of filter coefficients."}, {"type": "Point", "name": "_anchor", "description": null}, {"type": "double", "name": "delta", "description": " \u2013 Value added to the filtered results before storing them."}, {"type": "int", "name": "rowBorderType", "description": " \u2013 Pixel extrapolation method in the vertical direction. For details, see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a>."}, {"type": "int", "name": "columnBorderType", "description": " \u2013 Pixel extrapolation method in the horizontal direction."}, {"type": "const Scalar&", "name": "borderValue", "description": " \u2013 Border value used in case of a constant border."}], "name": "Ptr<FilterEngine> createLinearFilter(int srcType, int dstType, InputArray kernel, Point _anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)", "description": "Creates a non-separable linear filter engine.", "fname": "createLinearFilter", "return_type": "Ptr<FilterEngine>"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image. It has the specified size and the same type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"type": "const Size&", "name": "dstsize", "description": " \u2013 <p>size of the output image; by default, it is computed as <tt class=\"docutils literal\"><span class=\"pre\">Size(src.cols*2,</span> <span class=\"pre\">(src.rows*2)</span></tt>, but in any case, the following conditions should be satisfied:</p> <div class=\"math\"> <p><img src=\"../../../_images/math/d8d6bc69566cf5200655b1c5a65733779ed6e113.png\" alt=\"\\begin{array}{l} | \\texttt{dstsize.width} -src.cols*2| \\leq ( \\texttt{dstsize.width} \\mod 2) \\\\ | \\texttt{dstsize.height} -src.rows*2| \\leq ( \\texttt{dstsize.height} \\mod 2) \\end{array}\"/></p> </div>"}, {"type": "int", "name": "borderType", "description": null}], "name": "void pyrUp(InputArray src, OutputArray dst, const Size& dstsize, int borderType)", "description": "Upsamples an image and then blurs it.", "fname": "pyrUp", "return_type": "void"}, {"pars": [{"type": "int", "name": "op", "description": " \u2013 Morphology operation ID, <tt class=\"docutils literal\"><span class=\"pre\">MORPH_ERODE</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">MORPH_DILATE</span></tt> ."}, {"type": "int", "name": "type", "description": " \u2013 Input/output image type. The number of channels can be arbitrary. The depth should be one of <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F`</span> <span class=\"pre\">or</span> <span class=\"pre\">``CV_64F</span></tt>."}, {"type": "int", "name": "ksize", "description": " \u2013 Horizontal or vertical structuring element size for separable morphological operations."}, {"type": "int", "name": "anchor", "description": " \u2013 Anchor position within the structuring element. Negative values mean that the anchor is at the kernel center."}], "name": "Ptr<BaseRowFilter> getMorphologyRowFilter(int op, int type, int ksize, int anchor)", "description": "Creates an engine for non-separable morphological operations.", "fname": "createMorphologyFilter", "return_type": "Ptr<BaseRowFilter>"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source image type."}, {"type": "int", "name": "sumType", "description": " \u2013 Intermediate horizontal sum type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "int", "name": "ksize", "description": " \u2013 Aperture size."}, {"type": "int", "name": "anchor", "description": " \u2013 Anchor position with the kernel. Negative values mean that the anchor is at the kernel center."}], "name": "Ptr<BaseRowFilter> getRowSumFilter(int srcType, int sumType, int ksize, int anchor)", "description": "Returns a box filter engine.", "fname": "createBoxFilter", "return_type": "Ptr<BaseRowFilter>"}, {"pars": [{"type": "int", "name": "srcType", "description": " \u2013 Source array type."}, {"type": "int", "name": "dstType", "description": " \u2013 Destination image type that must have as many channels as <tt class=\"docutils literal\"><span class=\"pre\">srcType</span></tt> ."}, {"type": "InputArray", "name": "rowKernel", "description": " \u2013 Coefficients for filtering each row."}, {"type": "InputArray", "name": "columnKernel", "description": " \u2013 Coefficients for filtering each column."}, {"type": "Point", "name": "anchor", "description": " \u2013 Anchor position within the kernel. Negative values mean that anchor is positioned at the aperture center."}, {"type": "double", "name": "delta", "description": " \u2013 Value added to the filtered results before storing them."}, {"type": "int", "name": "rowBorderType", "description": " \u2013 Pixel extrapolation method in the vertical direction. For details, see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a>."}, {"type": "int", "name": "columnBorderType", "description": " \u2013 Pixel extrapolation method in the horizontal direction."}, {"type": "const Scalar&", "name": "borderValue", "description": " \u2013 Border value used in case of a constant border."}], "name": "Ptr<FilterEngine> createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor, double delta, int rowBorderType, int columnBorderType, const Scalar& borderValue)", "description": "Creates an engine for a separable linear filter.", "fname": "createSeparableLinearFilter", "return_type": "Ptr<FilterEngine>"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input 1-, 3-, or 4-channel image; when <tt class=\"docutils literal\"><span class=\"pre\">ksize</span></tt> is 3 or 5, the image depth should be <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_16U</span></tt>, or <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>, for larger aperture sizes, it can only be <tt class=\"docutils literal\"><span class=\"pre\">CV_8U</span></tt>."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 destination array of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "int", "name": "ksize", "description": " \u2013 aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ..."}], "name": "void medianBlur(InputArray src, OutputArray dst, int ksize)", "description": "Blurs an image using the median filter.", "fname": "medianBlur", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 input image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 output image of the same size and the same number of channels as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>."}, {"type": "int", "name": "ddepth", "description": " \u2013 output image depth (see <a class=\"reference internal\" href=\"#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\" title=\"void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">Sobel()</span></tt></a> for the list of supported combination of <tt class=\"docutils literal\"><span class=\"pre\">src.depth()</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">ddepth</span></tt>)."}, {"type": "int", "name": "dx", "description": " \u2013 order of the derivative x."}, {"type": "int", "name": "dy", "description": " \u2013 order of the derivative y."}, {"type": "double", "name": "scale", "description": " \u2013 optional scale factor for the computed derivative values; by default, no scaling is applied (see <a class=\"reference internal\" href=\"#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\" title=\"void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getDerivKernels()</span></tt></a> for details)."}, {"type": "double", "name": "delta", "description": " \u2013 optional delta value that is added to the results prior to storing them in <tt class=\"docutils literal\"><span class=\"pre\">dst</span></tt>."}, {"type": "int", "name": "borderType", "description": " \u2013 pixel extrapolation method (see <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details)."}], "name": "void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)", "description": "Calculates the first x- or y- image derivative using Scharr operator.", "fname": "Scharr", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 Source image."}, {"type": "OutputArray", "name": "dst", "description": " \u2013 Destination image of the same size and the same number of channels as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"type": "int", "name": "ddepth", "description": " \u2013 Desired depth of the destination image."}, {"type": "int", "name": "ksize", "description": " \u2013 Aperture size used to compute the second-derivative filters. See <a class=\"reference internal\" href=\"#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\" title=\"void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getDerivKernels()</span></tt></a> for details. The size must be positive and odd."}, {"type": "double", "name": "scale", "description": " \u2013 Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See <a class=\"reference internal\" href=\"#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\" title=\"void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">getDerivKernels()</span></tt></a> for details."}, {"type": "double", "name": "delta", "description": " \u2013 Optional delta value that is added to the results prior to storing them in <tt class=\"docutils literal\"><span class=\"pre\">dst</span></tt> ."}, {"type": "int", "name": "borderType", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> for details."}], "name": "void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)", "description": "Calculates the Laplacian of an image.", "fname": "Laplacian", "return_type": "void"}, {"pars": [{"type": "InputArray", "name": "src", "description": " \u2013 Source image. Check <a class=\"reference internal\" href=\"#void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)\" title=\"void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">pyrDown()</span></tt></a> for the list of supported types."}, {"type": "OutputArrayOfArrays", "name": "dst", "description": " \u2013 Destination vector of <tt class=\"docutils literal\"><span class=\"pre\">maxlevel+1</span></tt> images of the same type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> . <tt class=\"docutils literal\"><span class=\"pre\">dst[0]</span></tt> will be the same as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> . <tt class=\"docutils literal\"><span class=\"pre\">dst[1]</span></tt> is the next pyramid layer, a smoothed and down-sized <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> , and so on."}, {"type": "int", "name": "maxlevel", "description": " \u2013 0-based index of the last (the smallest) pyramid layer. It must be non-negative."}, {"type": "int", "name": "borderType", "description": null}], "name": "void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)", "description": "Constructs the Gaussian pyramid for an image.", "fname": "buildPyramid", "return_type": "void"}]}}