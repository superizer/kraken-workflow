{"function": {"cv": [{"pars": [{"name": "src", "description": " \u2013 8-bit, single-channel (binary) source image.", "type": "InputArray"}, {"name": "dst", "description": " \u2013 Output image with calculated distances. It is a 32-bit floating-point, single-channel image of the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> .", "type": "OutputArray"}, {"name": "distanceType", "description": " \u2013 Type of distance. It can be <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_L1,</span> <span class=\"pre\">CV_DIST_L2</span></tt> , or <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_C</span></tt> .", "type": "int"}, {"name": "maskSize", "description": " \u2013 Size of the distance transform mask. It can be 3, 5, or <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_MASK_PRECISE</span></tt> (the latter option is only supported by the first function). In case of the <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_L1</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_C</span></tt> distance type, the parameter is forced to 3 because a <img class=\"math\" src=\"../../../_images/math/7b5343f2d9e22816e8de24262565ff2937695b2c.png\" alt=\"3\\times 3\"/> mask gives the same result as <img class=\"math\" src=\"../../../_images/math/ef7fe7592026585cc36e4d7c6036f19fd8afdc29.png\" alt=\"5\\times 5\"/> or any larger aperture.", "type": "int"}], "return_type": "void", "name": "void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize)", "description": "Calculates the distance to the closest zero pixel for each pixel of the source image.", "fname": "distancetransform"}, {"pars": [{"name": "src", "description": null, "type": "InputArray"}, {"name": "sum", "description": " \u2013 integral image as <img class=\"math\" src=\"../../../_images/math/5e0d46c91b1c52c25608cd99ff81e430cfe4c8a1.png\" alt=\"(W+1)\\times (H+1)\"/> , 32-bit integer or floating-point (32f or 64f).", "type": "OutputArray"}, {"name": "sqsum", "description": " \u2013 integral image for squared pixel values; it is <img class=\"math\" src=\"../../../_images/math/5e0d46c91b1c52c25608cd99ff81e430cfe4c8a1.png\" alt=\"(W+1)\\times (H+1)\"/>, double-precision floating-point (64f) array.", "type": "OutputArray"}, {"name": "sdepth", "description": " \u2013 desired depth of the integral and the tilted integral images, <tt class=\"docutils literal\"><span class=\"pre\">CV_32S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>, or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>.", "type": "int"}], "return_type": "void", "name": "void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth)", "description": "Calculates the integral of an image.", "fname": "integral"}, {"pars": [{"name": "image", "description": " \u2013 Input 8-bit 3-channel image.", "type": "InputArray"}, {"name": "markers", "description": " \u2013 Input/output 32-bit single-channel image (map) of markers. It should have the same size as <tt class=\"docutils literal\"><span class=\"pre\">image</span></tt> .", "type": "InputOutputArray"}], "return_type": "void", "name": "void watershed(InputArray image, InputOutputArray markers)", "description": "Performs a marker-based image segmentation using the watershed algorithm.", "fname": "watershed"}, {"pars": [{"name": "src", "description": " \u2013 input image: 8-bit unsigned, 16-bit unsigned ( <tt class=\"docutils literal\"><span class=\"pre\">CV_16UC...</span></tt> ), or single-precision floating-point.", "type": "InputArray"}, {"name": "dst", "description": " \u2013 output image of the same size and depth as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>.", "type": "OutputArray"}, {"name": "code", "description": " \u2013 color space conversion code (see the description below).", "type": "int"}, {"name": "dstCn", "description": " \u2013 number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">code</span></tt> .", "type": "int"}], "return_type": "void", "name": "void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)", "description": "Converts an image from one color space to another.", "fname": "cvtcolor"}, {"pars": [{"name": "src", "description": " \u2013 input array (single-channel, 8-bit or 32-bit floating point).", "type": "InputArray"}, {"name": "dst", "description": " \u2013 output array of the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt>.", "type": "OutputArray"}, {"name": "thresh", "description": " \u2013 threshold value.", "type": "double"}, {"name": "maxval", "description": " \u2013 maximum value to use with the <tt class=\"docutils literal\"><span class=\"pre\">THRESH_BINARY</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">THRESH_BINARY_INV</span></tt> thresholding types.", "type": "double"}, {"name": "type", "description": " \u2013 thresholding type (see the details below).", "type": "int"}], "return_type": "double", "name": "double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)", "description": "Applies a fixed-level threshold to each array element.", "fname": "threshold"}, {"pars": [{"name": "src", "description": " \u2013 Source 8-bit single-channel image.", "type": "InputArray"}, {"name": "dst", "description": " \u2013 Destination image of the same size and the same type as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> .", "type": "OutputArray"}, {"name": "maxValue", "description": " \u2013 Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.", "type": "double"}, {"name": "adaptiveMethod", "description": " \u2013 Adaptive thresholding algorithm to use, <tt class=\"docutils literal\"><span class=\"pre\">ADAPTIVE_THRESH_MEAN_C</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">ADAPTIVE_THRESH_GAUSSIAN_C</span></tt> . See the details below.", "type": "int"}, {"name": "thresholdType", "description": " \u2013 Thresholding type that must be either <tt class=\"docutils literal\"><span class=\"pre\">THRESH_BINARY</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">THRESH_BINARY_INV</span></tt> .", "type": "int"}, {"name": "blockSize", "description": " \u2013 Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.", "type": "int"}, {"name": "C", "description": " \u2013 Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.", "type": "double"}], "return_type": "void", "name": "void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)", "description": "Applies an adaptive threshold to an array.", "fname": "adaptivethreshold"}, {"pars": [{"name": "image", "description": " \u2013 Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <tt class=\"docutils literal\"><span class=\"pre\">FLOODFILL_MASK_ONLY</span></tt> flag is set in the second variant of the function. See the details below.", "type": "InputOutputArray"}, {"name": "seedPoint", "description": " \u2013 Starting point.", "type": "Point"}, {"name": "newVal", "description": " \u2013 New value of the repainted domain pixels.", "type": "Scalar"}, {"name": "rect", "description": " \u2013 Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain.", "type": "Rect*"}, {"name": "loDiff", "description": " \u2013 Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.", "type": "Scalar"}, {"name": "upDiff", "description": " \u2013 Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.", "type": "Scalar"}, {"name": "flags", "description": " \u2013 <p>Operation flags. Lower bits contain a connectivity value, 4 (default) or 8, used within the function. Connectivity determines which neighbors of a pixel are considered. Upper bits can be 0 or a combination of the following flags:</p> <ul> <li><strong>FLOODFILL_FIXED_RANGE</strong> If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating).", "type": "int"}], "return_type": "int", "name": "int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)", "description": "Fills a connected component with the given color.", "fname": "floodfill"}, {"pars": [{"name": "src", "description": " \u2013 8-bit, single-channel (binary) source image.", "type": "InputArray"}, {"name": "dst", "description": " \u2013 Output image with calculated distances. It is a 32-bit floating-point, single-channel image of the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> .", "type": "OutputArray"}, {"name": "labels", "description": " \u2013 Optional output 2D array of labels (the discrete Voronoi diagram). It has the type <tt class=\"docutils literal\"><span class=\"pre\">CV_32SC1</span></tt> and the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> . See the details below.", "type": "OutputArray"}, {"name": "distanceType", "description": " \u2013 Type of distance. It can be <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_L1,</span> <span class=\"pre\">CV_DIST_L2</span></tt> , or <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_C</span></tt> .", "type": "int"}, {"name": "maskSize", "description": " \u2013 Size of the distance transform mask. It can be 3, 5, or <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_MASK_PRECISE</span></tt> (the latter option is only supported by the first function). In case of the <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_L1</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">CV_DIST_C</span></tt> distance type, the parameter is forced to 3 because a <img class=\"math\" src=\"../../../_images/math/7b5343f2d9e22816e8de24262565ff2937695b2c.png\" alt=\"3\\times 3\"/> mask gives the same result as <img class=\"math\" src=\"../../../_images/math/ef7fe7592026585cc36e4d7c6036f19fd8afdc29.png\" alt=\"5\\times 5\"/> or any larger aperture.", "type": "int"}, {"name": "labelType", "description": " \u2013 Type of the label array to build. If <tt class=\"docutils literal\"><span class=\"pre\">labelType==DIST_LABEL_CCOMP</span></tt> then each connected component of zeros in <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> (as well as all the non-zero pixels closest to the connected component) will be assigned the same label. If <tt class=\"docutils literal\"><span class=\"pre\">labelType==DIST_LABEL_PIXEL</span></tt> then each zero pixel (and all the non-zero pixels closest to it) gets its own label.", "type": "int"}], "return_type": "void", "name": "void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType)", "description": "Calculates the distance to the closest zero pixel for each pixel of the source image.", "fname": "distancetransform"}, {"pars": [{"name": "src", "description": null, "type": "InputArray"}, {"name": "sum", "description": " \u2013 integral image as <img class=\"math\" src=\"../../../_images/math/5e0d46c91b1c52c25608cd99ff81e430cfe4c8a1.png\" alt=\"(W+1)\\times (H+1)\"/> , 32-bit integer or floating-point (32f or 64f).", "type": "OutputArray"}, {"name": "sdepth", "description": " \u2013 desired depth of the integral and the tilted integral images, <tt class=\"docutils literal\"><span class=\"pre\">CV_32S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>, or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>.", "type": "int"}], "return_type": "void", "name": "void integral(InputArray src, OutputArray sum, int sdepth)", "description": "Calculates the integral of an image.", "fname": "integral"}, {"pars": [{"name": "src", "description": null, "type": "InputArray"}, {"name": "sum", "description": " \u2013 integral image as <img class=\"math\" src=\"../../../_images/math/5e0d46c91b1c52c25608cd99ff81e430cfe4c8a1.png\" alt=\"(W+1)\\times (H+1)\"/> , 32-bit integer or floating-point (32f or 64f).", "type": "OutputArray"}, {"name": "sqsum", "description": " \u2013 integral image for squared pixel values; it is <img class=\"math\" src=\"../../../_images/math/5e0d46c91b1c52c25608cd99ff81e430cfe4c8a1.png\" alt=\"(W+1)\\times (H+1)\"/>, double-precision floating-point (64f) array.", "type": "OutputArray"}, {"name": "tilted", "description": " \u2013 integral for the image rotated by 45 degrees; it is <img class=\"math\" src=\"../../../_images/math/5e0d46c91b1c52c25608cd99ff81e430cfe4c8a1.png\" alt=\"(W+1)\\times (H+1)\"/> array with the same data type as <tt class=\"docutils literal\"><span class=\"pre\">sum</span></tt>.", "type": "OutputArray"}, {"name": "sdepth", "description": " \u2013 desired depth of the integral and the tilted integral images, <tt class=\"docutils literal\"><span class=\"pre\">CV_32S</span></tt>, <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt>, or <tt class=\"docutils literal\"><span class=\"pre\">CV_64F</span></tt>.", "type": "int"}], "return_type": "void", "name": "void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth)", "description": "Calculates the integral of an image.", "fname": "integral"}, {"pars": [{"name": "image", "description": " \u2013 Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the <tt class=\"docutils literal\"><span class=\"pre\">FLOODFILL_MASK_ONLY</span></tt> flag is set in the second variant of the function. See the details below.", "type": "InputOutputArray"}, {"name": "mask", "description": " \u2013 <p>(For the second function only) Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of initializing the <tt class=\"docutils literal\"><span class=\"pre\">mask</span></tt> content. Flood-filling cannot go across non-zero pixels in the mask. For example, an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask in multiple calls to the function to make sure the filled area does not overlap.</p> <div class=\"admonition note\"> <p class=\"first admonition-title\">Note</p> <p class=\"last\">Since the mask is larger than the filled image, a pixel <img class=\"math\" src=\"../../../_images/math/adfd9ae8a3fac031d3b8b470a52a709a23d4d6d2.png\" alt=\"(x, y)\"/> in <tt class=\"docutils literal\"><span class=\"pre\">image</span></tt> corresponds to the pixel <img class=\"math\" src=\"../../../_images/math/c46b66bff9d47bab8abdb3bf589d80ad6f01d20c.png\" alt=\"(x+1, y+1)\"/> in the <tt class=\"docutils literal\"><span class=\"pre\">mask</span></tt> .</p> </div> ", "type": "InputOutputArray"}, {"name": "seedPoint", "description": " \u2013 Starting point.", "type": "Point"}, {"name": "newVal", "description": " \u2013 New value of the repainted domain pixels.", "type": "Scalar"}, {"name": "rect", "description": " \u2013 Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain.", "type": "Rect*"}, {"name": "loDiff", "description": " \u2013 Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.", "type": "Scalar"}, {"name": "upDiff", "description": " \u2013 Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.", "type": "Scalar"}, {"name": "flags", "description": " \u2013 <p>Operation flags. Lower bits contain a connectivity value, 4 (default) or 8, used within the function. Connectivity determines which neighbors of a pixel are considered. Upper bits can be 0 or a combination of the following flags:</p> <ul> <li><strong>FLOODFILL_FIXED_RANGE</strong> If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating).", "type": "int"}], "return_type": "int", "name": "int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)", "description": "Fills a connected component with the given color.", "fname": "floodfill"}, {"pars": [{"name": "img", "description": " \u2013 Input 8-bit 3-channel image.", "type": "InputArray"}, {"name": "mask", "description": " \u2013 <p>Input/output 8-bit single-channel mask. The mask is initialized by the function when <tt class=\"docutils literal\"><span class=\"pre\">mode</span></tt> is set to <tt class=\"docutils literal\"><span class=\"pre\">GC_INIT_WITH_RECT</span></tt>. Its elements may have one of following values:</p> <ul> <li><strong>GC_BGD</strong> defines an obvious background pixels.", "type": "InputOutputArray"}, {"name": "rect", "description": " \u2013 ROI containing a segmented object. The pixels outside of the ROI are marked as \u201cobvious background\u201d. The parameter is only used when <tt class=\"docutils literal\"><span class=\"pre\">mode==GC_INIT_WITH_RECT</span></tt> .", "type": "Rect"}, {"name": "bgdModel", "description": " \u2013 Temporary array for the background model. Do not modify it while you are processing the same image.", "type": "InputOutputArray"}, {"name": "fgdModel", "description": " \u2013 Temporary arrays for the foreground model. Do not modify it while you are processing the same image.", "type": "InputOutputArray"}, {"name": "iterCount", "description": " \u2013 Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with <tt class=\"docutils literal\"><span class=\"pre\">mode==GC_INIT_WITH_MASK</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">mode==GC_EVAL</span></tt> .", "type": "int"}, {"name": "mode", "description": " \u2013 <p>Operation mode that could be one of the following:</p> <ul> <li><strong>GC_INIT_WITH_RECT</strong> The function initializes the state and the mask using the provided rectangle. After that it runs <tt class=\"docutils literal\"><span class=\"pre\">iterCount</span></tt> iterations of the algorithm.", "type": "int"}], "return_type": "void", "name": "void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode)", "description": "Runs the GrabCut algorithm.", "fname": "grabcut"}]}}