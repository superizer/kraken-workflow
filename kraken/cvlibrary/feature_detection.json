{"function": {"cv": [{"pars": [{"name": "image", "type": "InputArray", "description": " \u2013 8-bit, single-channel, grayscale input image."}, {"name": "circles", "type": "OutputArray", "description": " \u2013 Output vector of found circles. Each vector is encoded as a 3-element floating-point vector <img class=\"math\" src=\"../../../_images/math/597697addc29342e3b0fe01206c94e9cb52c169e.png\" alt=\"(x, y, radius)\"/> ."}, {"name": "method", "type": "int", "description": " \u2013 Detection method to use. Currently, the only implemented method is <tt class=\"docutils literal\"><span class=\"pre\">CV_HOUGH_GRADIENT</span></tt> , which is basically <em>21HT</em> , described in <a class=\"reference internal\" href=\"#yuen90\">[Yuen90]</a>."}, {"name": "dp", "type": "double", "description": " \u2013 Inverse ratio of the accumulator resolution to the image resolution. For example, if <tt class=\"docutils literal\"><span class=\"pre\">dp=1</span></tt> , the accumulator has the same resolution as the input image. If <tt class=\"docutils literal\"><span class=\"pre\">dp=2</span></tt> , the accumulator has half as big width and height."}, {"name": "minDist", "type": "double", "description": " \u2013 Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed."}, {"name": "param1", "type": "double", "description": " \u2013 First method-specific parameter. In case of <tt class=\"docutils literal\"><span class=\"pre\">CV_HOUGH_GRADIENT</span></tt> , it is the higher threshold of the two passed to the <a class=\"reference internal\" href=\"#void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize, bool L2gradient)\" title=\"void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize, bool L2gradient)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">Canny()</span></tt></a> edge detector (the lower one is twice smaller)."}, {"name": "param2", "type": "double", "description": " \u2013 Second method-specific parameter. In case of <tt class=\"docutils literal\"><span class=\"pre\">CV_HOUGH_GRADIENT</span></tt> , it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first."}, {"name": "minRadius", "type": "int", "description": " \u2013 Minimum circle radius."}, {"name": "maxRadius", "type": "int", "description": " \u2013 Maximum circle radius."}], "fname": "HoughCircles", "return_type": "void", "name": "void HoughCircles(InputArray image, OutputArray circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)", "description": "Finds circles in a grayscale image using the Hough transform."}, {"pars": [{"name": "src", "type": "InputArray", "description": " \u2013 Input single-channel 8-bit or floating-point image."}, {"name": "dst", "type": "OutputArray", "description": " \u2013 Image to store the results. It has the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> and the type <tt class=\"docutils literal\"><span class=\"pre\">CV_32FC(6)</span></tt> ."}, {"name": "blockSize", "type": "int", "description": " \u2013 Neighborhood size (see details below)."}, {"name": "ksize", "type": "int", "description": " \u2013 Aperture parameter for the <a class=\"reference internal\" href=\"filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\" title=\"void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">Sobel()</span></tt></a> operator."}, {"name": "borderType", "type": "int", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"filtering.html#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "fname": "cornerEigenValsAndVecs", "return_type": "void", "name": "void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)", "description": "Calculates eigenvalues and eigenvectors of image blocks for corner detection."}, {"pars": [{"name": "src", "type": "InputArray", "description": " \u2013 Input single-channel 8-bit or floating-point image."}, {"name": "dst", "type": "OutputArray", "description": " \u2013 Image to store the minimal eigenvalues. It has the type <tt class=\"docutils literal\"><span class=\"pre\">CV_32FC1</span></tt> and the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"name": "blockSize", "type": "int", "description": " \u2013 Neighborhood size (see the details on <a class=\"reference internal\" href=\"#void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\" title=\"void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerEigenValsAndVecs()</span></tt></a> )."}, {"name": "ksize", "type": "int", "description": " \u2013 Aperture parameter for the <a class=\"reference internal\" href=\"filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\" title=\"void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">Sobel()</span></tt></a> operator."}, {"name": "borderType", "type": "int", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"filtering.html#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "fname": "cornerMinEigenVal", "return_type": "void", "name": "void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)", "description": "Calculates the minimal eigenvalue of gradient matrices for corner detection."}, {"pars": [{"name": "image", "type": "InputArray", "description": " \u2013 8-bit, single-channel binary source image. The image may be modified by the function."}, {"name": "lines", "type": "OutputArray", "description": " \u2013 Output vector of lines. Each line is represented by a 4-element vector <img class=\"math\" src=\"../../../_images/math/ebf41cd6a7ab1c72b6a1e6cbcc00f2af3663d249.png\" alt=\"(x_1, y_1, x_2, y_2)\"/> , where <img class=\"math\" src=\"../../../_images/math/b354638f824de285dce6d6d3f72163cb287aeff7.png\" alt=\"(x_1,y_1)\"/> and <img class=\"math\" src=\"../../../_images/math/574cd26ba0fbfb46272d82eb95420c5fdbc53546.png\" alt=\"(x_2, y_2)\"/> are the ending points of each detected line segment."}, {"name": "rho", "type": "double", "description": " \u2013 Distance resolution of the accumulator in pixels."}, {"name": "theta", "type": "double", "description": " \u2013 Angle resolution of the accumulator in radians."}, {"name": "threshold", "type": "int", "description": " \u2013 Accumulator threshold parameter. Only those lines are returned that get enough votes ( <img class=\"math\" src=\"../../../_images/math/6137700db6e8e9a225e8c6b0d688661726f622a6.png\" alt=\">\\texttt{threshold}\"/> )."}, {"name": "minLineLength", "type": "double", "description": " \u2013 Minimum line length. Line segments shorter than that are rejected."}, {"name": "maxLineGap", "type": "double", "description": " \u2013 Maximum allowed gap between points on the same line to link them."}], "fname": "HoughLinesP", "return_type": "void", "name": "void HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)", "description": "Finds line segments in a binary image using the probabilistic Hough transform."}, {"pars": [{"name": "src", "type": "InputArray", "description": " \u2013 Source single-channel 8-bit of floating-point image."}, {"name": "dst", "type": "OutputArray", "description": " \u2013 Output image that has the type <tt class=\"docutils literal\"><span class=\"pre\">CV_32F</span></tt> and the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"name": "ksize", "type": "int", "description": " \u2013 Aperture size of the <a class=\"reference internal\" href=\"filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\" title=\"void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">Sobel()</span></tt></a> ."}, {"name": "borderType", "type": "int", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"filtering.html#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "fname": "preCornerDetect", "return_type": "void", "name": "void preCornerDetect(InputArray src, OutputArray dst, int ksize, int borderType)", "description": "Calculates a feature map for corner detection."}, {"pars": [{"name": "image", "type": "InputArray", "description": " \u2013 8-bit, single-channel binary source image. The image may be modified by the function."}, {"name": "lines", "type": "OutputArray", "description": " \u2013 Output vector of lines. Each line is represented by a two-element vector <img class=\"math\" src=\"../../../_images/math/f1459a92b92542485c95d273a0aa529dc4ecb6ac.png\" alt=\"(\\rho, \\theta)\"/> . <img class=\"math\" src=\"../../../_images/math/0027034d8a10372a06deaf4f4084c01956587479.png\" alt=\"\\rho\"/> is the distance from the coordinate origin <img class=\"math\" src=\"../../../_images/math/f9603ca3089464e548fc6f1366bc474e7efef8d9.png\" alt=\"(0,0)\"/> (top-left corner of the image). <img class=\"math\" src=\"../../../_images/math/52e8ed7a3ba22130ad3984eb2cd413406475a689.png\" alt=\"\\theta\"/> is the line rotation angle in radians ( <img class=\"math\" src=\"../../../_images/math/3d7090dbb671c2e58794b61a53951cd1e802f6de.png\" alt=\"0 \\sim \\textrm{vertical line}, \\pi/2 \\sim \\textrm{horizontal line}\"/> )."}, {"name": "rho", "type": "double", "description": " \u2013 Distance resolution of the accumulator in pixels."}, {"name": "theta", "type": "double", "description": " \u2013 Angle resolution of the accumulator in radians."}, {"name": "threshold", "type": "int", "description": " \u2013 Accumulator threshold parameter. Only those lines are returned that get enough votes ( <img class=\"math\" src=\"../../../_images/math/6137700db6e8e9a225e8c6b0d688661726f622a6.png\" alt=\">\\texttt{threshold}\"/> )."}, {"name": "srn", "type": "double", "description": " \u2013 For the multi-scale Hough transform, it is a divisor for the distance resolution <tt class=\"docutils literal\"><span class=\"pre\">rho</span></tt> . The coarse accumulator distance resolution is <tt class=\"docutils literal\"><span class=\"pre\">rho</span></tt> and the accurate accumulator resolution is <tt class=\"docutils literal\"><span class=\"pre\">rho/srn</span></tt> . If both <tt class=\"docutils literal\"><span class=\"pre\">srn=0</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">stn=0</span></tt> , the classical Hough transform is used. Otherwise, both these parameters should be positive."}, {"name": "stn", "type": "double", "description": " \u2013 For the multi-scale Hough transform, it is a divisor for the distance resolution <tt class=\"docutils literal\"><span class=\"pre\">theta</span></tt>."}], "fname": "HoughLines", "return_type": "void", "name": "void HoughLines(InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn, double stn)", "description": "Finds lines in a binary image using the standard Hough transform."}, {"pars": [{"name": "image", "type": "InputArray", "description": " \u2013 single-channel 8-bit input image."}, {"name": "edges", "type": "OutputArray", "description": " \u2013 output edge map; it has the same size and type as <tt class=\"docutils literal\"><span class=\"pre\">image</span></tt> ."}, {"name": "threshold1", "type": "double", "description": " \u2013 first threshold for the hysteresis procedure."}, {"name": "threshold2", "type": "double", "description": " \u2013 second threshold for the hysteresis procedure."}, {"name": "apertureSize", "type": "int", "description": " \u2013 aperture size for the <a class=\"reference internal\" href=\"filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\" title=\"void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">Sobel()</span></tt></a> operator."}, {"name": "L2gradient", "type": "bool", "description": " \u2013 a flag, indicating whether a more accurate <img class=\"math\" src=\"../../../_images/math/e13a902eb6a24cf493a2732badd0d151fb4f7672.png\" alt=\"L_2\"/> norm <img class=\"math\" src=\"../../../_images/math/21cf199f290de46245757d21ff3ce135f74901ce.png\" alt=\"=\\sqrt{(dI/dx)^2 + (dI/dy)^2}\"/> should be used to calculate the image gradient magnitude ( <tt class=\"docutils literal\"><span class=\"pre\">L2gradient=true</span></tt> ), or whether the default <img class=\"math\" src=\"../../../_images/math/3f22b669e4803ae525cf8120ca251e2eab025872.png\" alt=\"L_1\"/> norm <img class=\"math\" src=\"../../../_images/math/db12388db2d790e5d77079fd979a2817c91bf7bf.png\" alt=\"=|dI/dx|+|dI/dy|\"/> is enough ( <tt class=\"docutils literal\"><span class=\"pre\">L2gradient=false</span></tt> )."}], "fname": "Canny", "return_type": "void", "name": "void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize, bool L2gradient)", "description": "Finds edges in an image using the <a class=\"reference internal\" href=\"#canny86\">[Canny86]</a> algorithm."}, {"pars": [{"name": "src", "type": "InputArray", "description": " \u2013 Input single-channel 8-bit or floating-point image."}, {"name": "dst", "type": "OutputArray", "description": " \u2013 Image to store the Harris detector responses. It has the type <tt class=\"docutils literal\"><span class=\"pre\">CV_32FC1</span></tt> and the same size as <tt class=\"docutils literal\"><span class=\"pre\">src</span></tt> ."}, {"name": "blockSize", "type": "int", "description": " \u2013 Neighborhood size (see the details on <a class=\"reference internal\" href=\"#void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\" title=\"void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerEigenValsAndVecs()</span></tt></a> )."}, {"name": "ksize", "type": "int", "description": " \u2013 Harris detector free parameter. See the formula below."}, {"name": "k", "type": "double", "description": null}, {"name": "borderType", "type": "int", "description": " \u2013 Pixel extrapolation method. See <a class=\"reference internal\" href=\"filtering.html#int borderInterpolate(int p, int len, int borderType)\" title=\"int borderInterpolate(int p, int len, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">borderInterpolate()</span></tt></a> ."}], "fname": "cornerHarris", "return_type": "void", "name": "void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)", "description": "Harris edge detector."}, {"pars": [{"name": "image", "type": "InputArray", "description": " \u2013 Input image."}, {"name": "corners", "type": "InputOutputArray", "description": " \u2013 Initial coordinates of the input corners and refined coordinates provided for output."}, {"name": "winSize", "type": "Size", "description": " \u2013 Half of the side length of the search window. For example, if <tt class=\"docutils literal\"><span class=\"pre\">winSize=Size(5,5)</span></tt> , then a <img class=\"math\" src=\"../../../_images/math/24b46271113970e59154d1b9d48de1d9e4483fe9.png\" alt=\"5*2+1 \\times 5*2+1 = 11 \\times 11\"/> search window is used."}, {"name": "zeroZone", "type": "Size", "description": " \u2013 Half of the size of the dead region in the middle of the search zone over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size."}, {"name": "criteria", "type": "TermCriteria", "description": " \u2013 Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after <tt class=\"docutils literal\"><span class=\"pre\">criteria.maxCount</span></tt> iterations or when the corner position moves by less than <tt class=\"docutils literal\"><span class=\"pre\">criteria.epsilon</span></tt> on some iteration."}], "fname": "cornerSubPix", "return_type": "void", "name": "void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)", "description": "Refines the corner locations."}, {"pars": [{"name": "image", "type": "InputArray", "description": " \u2013 Input 8-bit or floating-point 32-bit, single-channel image."}, {"name": "corners", "type": "OutputArray", "description": " \u2013 Output vector of detected corners."}, {"name": "maxCorners", "type": "int", "description": " \u2013 Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned."}, {"name": "qualityLevel", "type": "double", "description": " \u2013 Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class=\"reference internal\" href=\"#void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\" title=\"void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerMinEigenVal()</span></tt></a> ) or the Harris function response (see <a class=\"reference internal\" href=\"#void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)\" title=\"void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerHarris()</span></tt></a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the <tt class=\"docutils literal\"><span class=\"pre\">qualityLevel=0.01</span></tt> , then all the corners with the quality measure less than 15 are rejected."}, {"name": "minDistance", "type": "double", "description": " \u2013 Minimum possible Euclidean distance between the returned corners."}, {"name": "mask", "type": "InputArray", "description": " \u2013 Optional region of interest. If the image is not empty (it needs to have the type <tt class=\"docutils literal\"><span class=\"pre\">CV_8UC1</span></tt> and the same size as <tt class=\"docutils literal\"><span class=\"pre\">image</span></tt> ), it specifies the region in which the corners are detected."}, {"name": "blockSize", "type": "int", "description": " \u2013 Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See <a class=\"reference internal\" href=\"#void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\" title=\"void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerEigenValsAndVecs()</span></tt></a> ."}, {"name": "useHarrisDetector", "type": "bool", "description": " \u2013 Parameter indicating whether to use a Harris detector (see <a class=\"reference internal\" href=\"#void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)\" title=\"void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerHarris()</span></tt></a>) or <a class=\"reference internal\" href=\"#void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\" title=\"void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)\"><tt class=\"xref ocv ocv-func docutils literal\"><span class=\"pre\">cornerMinEigenVal()</span></tt></a>."}, {"name": "k", "type": "double", "description": " \u2013 Free parameter of the Harris detector."}], "fname": "goodFeaturesToTrack", "return_type": "void", "name": "void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask, int blockSize, bool useHarrisDetector, double k)", "description": "Determines strong corners on an image."}]}}